<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CatalogBasedMigration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Neo4j Migrations (Core)</a> &gt; <a href="index.source.html" class="el_package">ac.simons.neo4j.migrations.core</a> &gt; <span class="el_source">CatalogBasedMigration.java</span></div><h1>CatalogBasedMigration.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ac.simons.neo4j.migrations.core;

import ac.simons.neo4j.migrations.core.catalog.Catalog;
import ac.simons.neo4j.migrations.core.catalog.CatalogDiff;
import ac.simons.neo4j.migrations.core.catalog.CatalogItem;
import ac.simons.neo4j.migrations.core.catalog.Constraint;
import ac.simons.neo4j.migrations.core.catalog.Index;
import ac.simons.neo4j.migrations.core.catalog.Name;
import ac.simons.neo4j.migrations.core.catalog.Operator;
import ac.simons.neo4j.migrations.core.catalog.RenderConfig;
import ac.simons.neo4j.migrations.core.catalog.Renderer;
import ac.simons.neo4j.migrations.core.internal.Neo4jEdition;
import ac.simons.neo4j.migrations.core.internal.Neo4jVersion;
import ac.simons.neo4j.migrations.core.internal.NodeSetDataImpl;
import ac.simons.neo4j.migrations.core.internal.NoopDOMCryptoContext;
import ac.simons.neo4j.migrations.core.internal.ThrowingErrorHandler;
import ac.simons.neo4j.migrations.core.internal.XMLSchemaConstants;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLDecoder;
import java.security.InvalidAlgorithmParameterException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.zip.CRC32;

import javax.xml.XMLConstants;
import javax.xml.crypto.XMLCryptoContext;
import javax.xml.crypto.dom.DOMStructure;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.TransformException;
import javax.xml.crypto.dsig.TransformService;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.neo4j.driver.QueryRunner;
import org.neo4j.driver.Session;
import org.neo4j.driver.exceptions.Neo4jException;
import org.neo4j.driver.summary.SummaryCounters;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * A migration based on a catalog. The migration itself can contain a (partial) catalog with items that will be added
 * to the {@link MigrationContext Migration contexts} global catalog. Items with the same ids in newer migrations will
 * be added to the catalog. They will be picked up by operations depending on which migration the operation is applied.
 *
 * @author Michael J. Simons
 * @soundtrack Tom Holkenborg - Terminator: Dark Fate
 * @since 1.7.0
 */
final class CatalogBasedMigration implements MigrationWithPreconditions {

<span class="fc" id="L94">	private static final Logger LOGGER = Logger.getLogger(CatalogBasedMigration.class.getName());</span>

	/**
	 * A reference to the schema for validating our input.
	 */
	private static final Schema MIGRATION_SCHEMA;
	/**
	 * Neither document builder factories nor document builders are thread safe, so here we areâ€¦
	 * This is supposed to stay there, otherwise I can spare myself the effort of a thread local.
	 */
	@SuppressWarnings(&quot;squid:S5164&quot;)
	private static final ThreadLocal&lt;DocumentBuilderFactory&gt; DOCUMENT_BUILDER_FACTORY;

	static {
		try {
<span class="fc" id="L109">			SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="fc" id="L110">			MIGRATION_SCHEMA = schemaFactory.newSchema(new StreamSource(</span>
<span class="fc" id="L111">				CatalogBasedMigration.class.getResourceAsStream(&quot;/ac/simons/neo4j/migrations/core/migration.xsd&quot;)));</span>
<span class="nc" id="L112">		} catch (SAXException e) {</span>
<span class="nc" id="L113">			throw new MigrationsException(&quot;Could not load XML schema definition for schema based migrations.&quot;, e);</span>
<span class="fc" id="L114">		}</span>

<span class="fc" id="L116">		DOCUMENT_BUILDER_FACTORY = ThreadLocal.withInitial(() -&gt; {</span>
<span class="fc" id="L117">			DocumentBuilderFactory value = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L118">			value.setSchema(MIGRATION_SCHEMA);</span>
<span class="fc" id="L119">			value.setExpandEntityReferences(false);</span>
<span class="fc" id="L120">			value.setNamespaceAware(true);</span>
<span class="fc" id="L121">			return value;</span>
		});
<span class="fc" id="L123">	}</span>

	private static String computeChecksum(Document document) {

<span class="fc" id="L127">		final NodeList allElements = document.getElementsByTagName(&quot;*&quot;);</span>

<span class="fc" id="L129">		Node newCatalog = document.createElement(XMLSchemaConstants.CATALOG);</span>
<span class="fc" id="L130">		Node oldCatalog = null;</span>
<span class="fc" id="L131">		Node constraints = null;</span>
<span class="fc" id="L132">		Node indexes = null;</span>

<span class="fc" id="L134">		final List&lt;Node&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		for (int i = 0; i &lt; allElements.getLength(); i++) {</span>
<span class="fc" id="L136">			Node currentItem = allElements.item(i);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">			if (currentItem.getLocalName().equals(XMLSchemaConstants.CATALOG)) {</span>
<span class="fc" id="L139">				oldCatalog = currentItem;</span>
<span class="fc" id="L140">				continue;</span>
			}
<span class="fc bfc" id="L142" title="All 2 branches covered.">			if (currentItem.getLocalName().equals(XMLSchemaConstants.INDEXES)) {</span>
<span class="fc" id="L143">				indexes = currentItem;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">			} else if (currentItem.getLocalName().equals(XMLSchemaConstants.CONSTRAINTS)) {</span>
<span class="fc" id="L145">				constraints = currentItem;</span>
			}
<span class="fc" id="L147">			elements.add(currentItem);</span>
<span class="fc" id="L148">			NodeList childNodes = currentItem.getChildNodes();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">			for (int j = 0; j &lt; childNodes.getLength(); ++j) {</span>
<span class="fc" id="L150">				Node childItem = childNodes.item(j);</span>
<span class="fc bfc" id="L151" title="All 4 branches covered.">				if (!(childItem instanceof CharacterData) || childItem.getTextContent().trim().isEmpty()) {</span>
<span class="fc" id="L152">					continue;</span>
				}

<span class="fc" id="L155">				CharacterData textNode = (CharacterData) childItem;</span>
<span class="fc" id="L156">				String content = Arrays</span>
<span class="fc" id="L157">					.stream(textNode.getTextContent().split(&quot;\r?\n&quot;))</span>
<span class="fc" id="L158">					.map(String::trim).collect(Collectors.joining(&quot;\n&quot;));</span>
<span class="fc" id="L159">				textNode.setData(content);</span>
<span class="fc" id="L160">				elements.add(textNode);</span>
			}
		}

<span class="fc bfc" id="L164" title="All 2 branches covered.">		if (oldCatalog != null) {</span>
<span class="fc" id="L165">			updateCatalog(oldCatalog, newCatalog);</span>
		}
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if (constraints != null) {</span>
<span class="fc" id="L168">			newCatalog.appendChild(constraints);</span>
		}
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if (indexes != null) {</span>
<span class="fc" id="L171">			newCatalog.appendChild(indexes);</span>
		}
<span class="fc" id="L173">		elements.add(newCatalog);</span>
<span class="fc" id="L174">		return canonicalizeAndChecksumElements(document, elements);</span>
	}

	private static void updateCatalog(Node oldCatalog, Node newCatalog) {
<span class="fc" id="L178">		oldCatalog.getParentNode().replaceChild(newCatalog, oldCatalog);</span>
<span class="fc" id="L179">		NamedNodeMap attributes = oldCatalog.getAttributes();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">		for (int i = 0; i &lt; attributes.getLength(); ++i) {</span>
<span class="fc" id="L181">			Node attribute = attributes.item(i);</span>
<span class="fc" id="L182">			attributes.removeNamedItem(attribute.getNodeName());</span>
<span class="fc" id="L183">			newCatalog.getAttributes().setNamedItem(attribute);</span>
		}
<span class="fc" id="L185">	}</span>

	private static String canonicalizeAndChecksumElements(Document document, List&lt;Node&gt; elements) {
<span class="fc" id="L188">		try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L189">			XMLCryptoContext cryptoContext = new NoopDOMCryptoContext();</span>
<span class="fc" id="L190">			TransformService transformService = TransformService.getInstance(CanonicalizationMethod.INCLUSIVE, &quot;DOM&quot;);</span>
<span class="fc" id="L191">			transformService.init(new DOMStructure(document.createElement(&quot;holder&quot;)), cryptoContext);</span>
<span class="fc" id="L192">			transformService.transform(NodeSetDataImpl.of(elements), cryptoContext, os);</span>

<span class="fc" id="L194">			os.flush();</span>

<span class="fc" id="L196">			final CRC32 crc32 = new CRC32();</span>
<span class="fc" id="L197">			byte[] bytes = os.toByteArray();</span>
<span class="fc" id="L198">			crc32.update(bytes, 0, bytes.length);</span>
<span class="fc" id="L199">			return Long.toString(crc32.getValue());</span>
<span class="nc" id="L200">		} catch (TransformException | NoSuchAlgorithmException | InvalidAlgorithmParameterException | IOException e) {</span>
<span class="nc" id="L201">			throw new MigrationsException(&quot;Could not canonicalize an xml document&quot;, e);</span>
		}
	}

	static Migration from(URL url) {

<span class="fc" id="L207">		String path = url.getPath();</span>
		try {
<span class="fc" id="L209">			path = URLDecoder.decode(path, Defaults.CYPHER_SCRIPT_ENCODING.name());</span>
<span class="nc" id="L210">		} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L211">			throw new MigrationsException(&quot;Somethings broken: UTF-8 encoding not supported.&quot;);</span>
<span class="fc" id="L212">		}</span>
<span class="fc" id="L213">		int lastIndexOf = path.lastIndexOf(&quot;/&quot;);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">		String fileName = lastIndexOf &lt; 0 ? path : path.substring(lastIndexOf + 1);</span>
<span class="fc" id="L215">		MigrationVersion version = MigrationVersion.parse(fileName);</span>

<span class="fc" id="L217">		Document document = parseDocument(url);</span>
<span class="fc" id="L218">		return new CatalogBasedMigration(fileName, version, computeChecksum(document), Catalog.of(document),</span>
<span class="fc" id="L219">			parseOperations(document, version), getPreconditions(document), isResetCatalog(document));</span>
	}

	static Document parseDocument(URL url) {

<span class="fc" id="L224">		try (InputStream source = url.openStream()) {</span>
<span class="fc" id="L225">			DocumentBuilder documentBuilder = DOCUMENT_BUILDER_FACTORY.get().newDocumentBuilder();</span>
<span class="fc" id="L226">			documentBuilder.setErrorHandler(new ThrowingErrorHandler());</span>
<span class="fc" id="L227">			Document document = documentBuilder.parse(source);</span>

<span class="fc" id="L229">			document.normalizeDocument();</span>

<span class="fc" id="L231">			return document;</span>
<span class="nc" id="L232">		} catch (SAXParseException e) {</span>
<span class="nc" id="L233">			throw new MigrationsException(&quot;Could not parse migration: &quot; + e.getMessage());</span>
<span class="nc" id="L234">		} catch (SAXException | IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L235">			throw new MigrationsException(&quot;Could not parse the given document&quot;, e);</span>
		}
	}

	static boolean isResetCatalog(Document document) {

<span class="fc" id="L241">		NodeList catalog = document.getElementsByTagName(XMLSchemaConstants.CATALOG);</span>
<span class="fc bfc" id="L242" title="All 4 branches covered.">		return catalog.getLength() == 1 &amp;&amp; Boolean.parseBoolean(((Element) catalog.item(0)).getAttribute(&quot;reset&quot;));</span>
	}

	static List&lt;Precondition&gt; getPreconditions(Node parentNode) {
<span class="fc" id="L246">		List&lt;Precondition&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L247">		NodeList childNodes = parentNode.getChildNodes();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">		for (int i = 0; i &lt; childNodes.getLength(); ++i) {</span>
<span class="fc" id="L249">			Node node = childNodes.item(i);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {</span>
<span class="fc" id="L251">				Precondition.parse(String.format(&quot;// %s %s&quot;, node.getNodeName(), node.getTextContent().trim()))</span>
<span class="fc" id="L252">					.ifPresent(result::add);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			} else if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L254">				result.addAll(getPreconditions(node));</span>
			}
		}
<span class="fc" id="L257">		return result;</span>
	}

	static List&lt;Operation&gt; parseOperations(Document document, MigrationVersion version) {

<span class="fc" id="L262">		List&lt;Operation&gt; result = new ArrayList&lt;&gt;();</span>

		// We read the elements as they come, as there is no way to say &quot;give me all elements of a given type&quot;
<span class="fc" id="L265">		NodeList migration = document.getElementsByTagName(&quot;migration&quot;);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">		if (migration.getLength() != 1) {</span>
<span class="nc" id="L267">			throw new MigrationsException(&quot;Invalid document: No &lt;migration /&gt; element.&quot;);</span>
		}
<span class="fc" id="L269">		NodeList childNodes = migration.item(0).getChildNodes();</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">		for (int i = 0; i &lt; childNodes.getLength(); ++i) {</span>
<span class="fc" id="L271">			Node node = childNodes.item(i);</span>
<span class="fc" id="L272">			String nodeName = node.getNodeName();</span>
<span class="fc bfc" id="L273" title="All 4 branches covered.">			if (!((node instanceof Element) &amp;&amp; XMLSchemaConstants.OPERATIONS.contains(nodeName))) {</span>
<span class="pc" id="L274">				LOGGER.fine(() -&gt; String.format(&quot;Skipping node: %s&quot;, nodeName));</span>
<span class="fc" id="L275">				continue;</span>
			}
<span class="fc" id="L277">			OperationType type = OperationType.valueOf(nodeName.toUpperCase(Locale.ROOT));</span>
<span class="fc" id="L278">			result.add(type.build((Element) node, version));</span>
		}

		// Make sure the operations are ordered if there are constraints (first) and indexes (second)
<span class="fc" id="L282">		Comparator&lt;CatalogItem&lt;?&gt;&gt; catalogItemComparator = (o1, o2) -&gt; {</span>
<span class="nc bnc" id="L283" title="All 4 branches missed.">			if (o1 instanceof Constraint &amp;&amp; o2 instanceof Index) {</span>
<span class="nc" id="L284">				return -1;</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">			} else if (o2 instanceof Constraint &amp;&amp; o1 instanceof Index) {</span>
<span class="nc" id="L286">				return 1;</span>
			}
<span class="nc" id="L288">			return 0;</span>
		};

<span class="fc" id="L291">		return result.stream().sorted((operation1, operation2) -&gt; {</span>
<span class="pc bpc" id="L292" title="1 of 4 branches missed.">					if (operation1 instanceof ItemSpecificOperation &amp;&amp; operation2 instanceof ItemSpecificOperation</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">					&amp;&amp; ((ItemSpecificOperation) operation1).getLocalItem().isPresent()</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">					&amp;&amp; ((ItemSpecificOperation) operation2).getLocalItem().isPresent()) {</span>
<span class="nc" id="L295">						CatalogItem&lt;?&gt; item1 = ((ItemSpecificOperation) operation1).getLocalItem().get();</span>
<span class="nc" id="L296">						CatalogItem&lt;?&gt; item2 = ((ItemSpecificOperation) operation2).getLocalItem().get();</span>
<span class="nc" id="L297">						return catalogItemComparator.compare(item1, item2);</span>
					}
<span class="fc" id="L299">					return 0;</span>
				})
<span class="fc" id="L301">				.collect(Collectors.toList());</span>
	}

	private final String source;

	private final MigrationVersion version;

	private final String checksum;

	private final Catalog catalog;

	private final List&lt;Operation&gt; operations;

	private final List&lt;Precondition&gt; preconditions;

	private final boolean resetCatalog;

	/**
	 * @see CypherBasedMigration#getAlternativeChecksums() and field
	 */
<span class="fc" id="L321">	private List&lt;String&gt; alternativeChecksums = Collections.emptyList();</span>

	private CatalogBasedMigration(String source, MigrationVersion version, String checksum, Catalog catalog,
<span class="fc" id="L324">		List&lt;Operation&gt; operations, List&lt;Precondition&gt; preconditions, boolean resetCatalog) {</span>
<span class="fc" id="L325">		this.source = source;</span>
<span class="fc" id="L326">		this.version = version;</span>
<span class="fc" id="L327">		this.checksum = checksum;</span>
<span class="fc" id="L328">		this.catalog = catalog;</span>
<span class="fc" id="L329">		this.operations = operations;</span>
<span class="fc" id="L330">		this.preconditions = preconditions;</span>
<span class="fc" id="L331">		this.resetCatalog = resetCatalog;</span>
<span class="fc" id="L332">	}</span>

	@Override
	public Optional&lt;String&gt; getChecksum() {
<span class="fc" id="L336">		return Optional.of(checksum);</span>
	}

	@Override
	public List&lt;String&gt; getAlternativeChecksums() {
<span class="nc" id="L341">		return Collections.unmodifiableList(alternativeChecksums);</span>
	}

	@Override
	public void setAlternativeChecksums(List&lt;String&gt; alternativeChecksums) {

<span class="fc" id="L347">		Objects.requireNonNull(alternativeChecksums);</span>
<span class="fc" id="L348">		this.alternativeChecksums = new ArrayList&lt;&gt;(alternativeChecksums);</span>
<span class="fc" id="L349">	}</span>

	@Override
	public MigrationVersion getVersion() {
<span class="fc" id="L353">		return version;</span>
	}

	@Override
	public String getDescription() {
<span class="fc" id="L358">		return version.getDescription();</span>
	}

	@Override
	public String getSource() {
<span class="fc" id="L363">		return source;</span>
	}

	Catalog getCatalog() {
<span class="fc" id="L367">		return catalog;</span>
	}

	boolean isResetCatalog() {
<span class="fc" id="L371">		return resetCatalog;</span>
	}

	@Override
	public void apply(MigrationContext context) {

<span class="fc" id="L377">		Neo4jVersion neo4jVersion = Neo4jVersion.of(context.getConnectionDetails().getServerVersion());</span>
<span class="fc" id="L378">		Neo4jEdition neo4jEdition = Neo4jEdition.of(context.getConnectionDetails().getServerEdition());</span>

<span class="fc" id="L380">		Catalog globalCatalog = context.getCatalog();</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (!(globalCatalog instanceof VersionedCatalog)) {</span>
<span class="nc" id="L382">			throw new MigrationsException(&quot;Cannot use catalog based migrations without a versioned catalog.&quot;);</span>
		}

<span class="fc" id="L385">		try (Session session = context.getSession()) {</span>
<span class="fc" id="L386">			OperationContext operationContext = new OperationContext(neo4jVersion, neo4jEdition,</span>
				(VersionedCatalog) globalCatalog, session);
<span class="fc" id="L388">			Counters counters = this.operations</span>
<span class="fc" id="L389">				.stream().sequential()</span>
<span class="fc" id="L390">				.map(op -&gt; op.execute(operationContext))</span>
<span class="fc" id="L391">				.reduce(Counters.empty(), Counters::add);</span>

<span class="fc" id="L393">			LOGGER.log(Level.FINE,</span>
				&quot;Removed {3} constraints and {1} indexes, added {2} constraints and {0} indexes in total.&quot;,
<span class="fc" id="L395">				counters.toArray());</span>
<span class="fc" id="L396">		} catch (VerificationFailedException e) {</span>
<span class="fc" id="L397">			throw new MigrationsException(</span>
<span class="fc" id="L398">				&quot;Could not apply migration &quot; + Migrations.toString(this) + &quot; verification failed: &quot; + e.getMessage());</span>
<span class="fc" id="L399">		}</span>
<span class="fc" id="L400">	}</span>

	@Override
	public List&lt;Precondition&gt; getPreconditions() {
<span class="fc" id="L404">		return Collections.unmodifiableList(preconditions);</span>
	}

	static class OperationContext {

		final Neo4jVersion version;

		final Neo4jEdition edition;

		final VersionedCatalog catalog;

		final QueryRunner queryRunner;

		OperationContext(Neo4jVersion version, Neo4jEdition edition, VersionedCatalog catalog,
<span class="fc" id="L418">			QueryRunner queryRunner) {</span>
<span class="fc" id="L419">			this.version = version;</span>
<span class="fc" id="L420">			this.edition = edition;</span>
<span class="fc" id="L421">			this.catalog = catalog;</span>
<span class="fc" id="L422">			this.queryRunner = queryRunner;</span>
<span class="fc" id="L423">		}</span>
	}

<span class="fc" id="L426">	private enum OperationType {</span>
<span class="fc" id="L427">		VERIFY,</span>
<span class="fc" id="L428">		CREATE,</span>
<span class="fc" id="L429">		DROP,</span>
<span class="fc" id="L430">		APPLY;</span>

		Operation build(Element operationElement, MigrationVersion targetVersion) {
<span class="pc bpc" id="L433" title="1 of 4 branches missed.">			switch (this) {</span>
				case VERIFY:
<span class="fc" id="L435">					return Operation</span>
<span class="fc" id="L436">						.verify(Boolean.parseBoolean(operationElement.getAttribute(&quot;useCurrent&quot;)))</span>
<span class="fc" id="L437">						.allowEquivalent(Boolean.parseBoolean(operationElement.getAttribute(&quot;allowEquivalent&quot;)))</span>
<span class="fc" id="L438">						.at(targetVersion);</span>
				case CREATE:
				case DROP:
<span class="fc" id="L441">					Optional&lt;Name&gt; optionalName = getOptionalReference(operationElement);</span>
<span class="fc" id="L442">					boolean ifNotExists = Boolean.parseBoolean(operationElement.getAttribute(&quot;ifNotExists&quot;));</span>
<span class="fc" id="L443">					boolean ifExists = Boolean.parseBoolean(operationElement.getAttribute(&quot;ifExists&quot;));</span>
<span class="fc" id="L444">					return optionalName.&lt;Operation&gt;map(name -&gt; {</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">						OperationBuilder&lt;?&gt; builder = this == CREATE ?</span>
<span class="fc" id="L446">							Operation.create(optionalName.get(), ifNotExists) :</span>
<span class="fc" id="L447">							Operation.drop(optionalName.get(), ifExists);</span>
<span class="fc" id="L448">						return builder.with(targetVersion);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">					}).orElseGet(() -&gt; this == CREATE ?</span>
<span class="fc" id="L450">						Operation.create(getLocalItem(operationElement), ifNotExists) :</span>
<span class="fc" id="L451">						Operation.drop(getLocalItem(operationElement), ifExists)</span>
					);
				case APPLY:
<span class="fc" id="L454">					return Operation.apply(targetVersion);</span>
			}
<span class="nc" id="L456">			throw new IllegalArgumentException(&quot;Unsupported operation type: &quot; + this);</span>
		}

		private Optional&lt;Name&gt; getOptionalReference(Element operationElement) {

<span class="fc bfc" id="L461" title="All 4 branches covered.">			if (operationElement.hasAttribute(&quot;ref&quot;) &amp;&amp; operationElement.hasAttribute(&quot;item&quot;)) {</span>
<span class="fc" id="L462">				throw new IllegalArgumentException(</span>
					&quot;Cannot create an operation referring to an item with both ref and item attributes. Please pick one.&quot;);
			}

			// operationElement.hasAttributes() won't work, as it will always return true as the element has a couple of defaulted attributes
<span class="fc bfc" id="L467" title="All 6 branches covered.">			if ((operationElement.hasAttribute(&quot;ref&quot;) || operationElement.hasAttribute(&quot;item&quot;)) &amp;&amp; hasLocalItem(</span>
				operationElement)) {
<span class="fc" id="L469">				throw new IllegalArgumentException(</span>
					&quot;Cannot create an operation referring to an element and defining an item locally at the same time.&quot;);
			}

<span class="fc bfc" id="L473" title="All 2 branches covered.">			if (operationElement.hasAttribute(&quot;ref&quot;)) {</span>
<span class="fc" id="L474">				return Optional.of(Name.of(operationElement.getAttribute(&quot;ref&quot;)));</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">			} else if (operationElement.hasAttribute(&quot;item&quot;)) {</span>
<span class="fc" id="L476">				return Optional.of(Name.of(operationElement.getAttribute(&quot;item&quot;)));</span>
			} else {
<span class="fc" id="L478">				return Optional.empty();</span>
			}
		}

		private CatalogItem&lt;?&gt; getLocalItem(Element operationElement) {

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">			if (operationElement.getElementsByTagName(&quot;constraint&quot;).getLength() == 1) {</span>
<span class="fc" id="L485">				return Constraint.parse((Element) operationElement.getElementsByTagName(&quot;constraint&quot;).item(0));</span>
			}

<span class="nc bnc" id="L488" title="All 2 branches missed.">			if (operationElement.getElementsByTagName(&quot;index&quot;).getLength() == 1) {</span>
<span class="nc" id="L489">				return Index.parse((Element) operationElement.getElementsByTagName(&quot;index&quot;).item(0));</span>
			}

<span class="nc" id="L492">			throw new UnsupportedOperationException(&quot;Could not get a local catalog item.&quot;);</span>
		}

		private boolean hasLocalItem(Element operationElement) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">			if (!operationElement.hasChildNodes()) {</span>
<span class="fc" id="L497">				return false;</span>
			}
<span class="fc" id="L499">			NodeList childNodes = operationElement.getChildNodes();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">			for (int i = 0; i &lt; childNodes.getLength(); ++i) {</span>
<span class="fc" id="L501">				Node child = childNodes.item(i);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">				if (child instanceof Element) {</span>
<span class="fc" id="L503">					return true;</span>
				}
			}
<span class="fc" id="L506">			return false;</span>
		}
	}

	interface Counters {

		static Counters empty() {
<span class="fc" id="L513">			return EmptyCounters.INSTANCE;</span>
		}

		static Counters of(SummaryCounters summaryCounters) {
<span class="fc" id="L517">			return new DefaultCounters(summaryCounters);</span>
		}

		static Counters of(int indexesAdded, int indexesRemoved, int constraintsAdded, int constraintsRemoved) {
<span class="pc bpc" id="L521" title="2 of 8 branches missed.">			if (indexesAdded == 0 &amp;&amp; indexesRemoved == 0 &amp;&amp; constraintsAdded == 0 &amp;&amp; constraintsRemoved == 0) {</span>
<span class="fc" id="L522">				return Counters.empty();</span>
			}
<span class="fc" id="L524">			return new DefaultCounters(indexesAdded, indexesRemoved, constraintsAdded, constraintsRemoved);</span>
		}

		/**
		 * @return number of indexes added to the schema.
		 */
		int indexesAdded();

		/**
		 * @return number of indexes removed from the schema.
		 */
		int indexesRemoved();

		/**
		 * @return number of constraints added to the schema.
		 */
		int constraintsAdded();

		/**
		 * @return number of constraints removed from the schema.
		 */
		int constraintsRemoved();

		/**
		 * Add {@code rhs} to this summary, creating a new one
		 *
		 * @param rhs The summary to add to this summary
		 * @return a new summary
		 */
		Counters add(Counters rhs);

		/**
		 * @return an array of the objects value, useful for loggers; values in the same order as {@link #of(int, int, int, int)}
		 */
		default Object[] toArray() {
<span class="fc" id="L559">			return new Object[] { this.indexesAdded(), this.indexesRemoved(), this.constraintsAdded(),</span>
<span class="fc" id="L560">				this.constraintsRemoved() };</span>
		}
	}

<span class="fc" id="L564">	private enum EmptyCounters implements Counters {</span>

<span class="fc" id="L566">		INSTANCE;</span>

		@Override
		public int indexesAdded() {
<span class="fc" id="L570">			return 0;</span>
		}

		@Override
		public int indexesRemoved() {
<span class="fc" id="L575">			return 0;</span>
		}

		@Override
		public int constraintsAdded() {
<span class="fc" id="L580">			return 0;</span>
		}

		@Override
		public int constraintsRemoved() {
<span class="fc" id="L585">			return 0;</span>
		}

		@Override
		public Counters add(Counters rhs) {
<span class="fc bfc" id="L590" title="All 2 branches covered.">			if (rhs == EmptyCounters.INSTANCE) {</span>
<span class="fc" id="L591">				return this;</span>
			}
<span class="fc" id="L593">			return new DefaultCounters(rhs.indexesAdded(), rhs.indexesRemoved(), rhs.constraintsAdded(),</span>
<span class="fc" id="L594">				rhs.constraintsRemoved());</span>
		}
	}

	private static class DefaultCounters implements Counters {

		private final int indexesAdded;

		private final int indexesRemoved;

		private final int constraintsAdded;

		private final int constraintsRemoved;

		DefaultCounters(SummaryCounters counters) {
<span class="fc" id="L609">			this(counters.indexesAdded(), counters.indexesRemoved(), counters.constraintsAdded(),</span>
<span class="fc" id="L610">				counters.constraintsRemoved());</span>
<span class="fc" id="L611">		}</span>

<span class="fc" id="L613">		DefaultCounters(int indexesAdded, int indexesRemoved, int constraintsAdded, int constraintsRemoved) {</span>
<span class="fc" id="L614">			this.indexesAdded = indexesAdded;</span>
<span class="fc" id="L615">			this.indexesRemoved = indexesRemoved;</span>
<span class="fc" id="L616">			this.constraintsAdded = constraintsAdded;</span>
<span class="fc" id="L617">			this.constraintsRemoved = constraintsRemoved;</span>
<span class="fc" id="L618">		}</span>

		@Override
		public int indexesAdded() {
<span class="fc" id="L622">			return indexesAdded;</span>
		}

		@Override
		public int indexesRemoved() {
<span class="fc" id="L627">			return indexesRemoved;</span>
		}

		@Override
		public int constraintsAdded() {
<span class="fc" id="L632">			return constraintsAdded;</span>
		}

		@Override
		public int constraintsRemoved() {
<span class="fc" id="L637">			return constraintsRemoved;</span>
		}

		@Override
		public Counters add(Counters rhs) {

<span class="fc bfc" id="L643" title="All 2 branches covered.">			if (rhs == EmptyCounters.INSTANCE) {</span>
<span class="fc" id="L644">				return this;</span>
			}
<span class="fc" id="L646">			return new DefaultCounters(</span>
<span class="fc" id="L647">				this.indexesAdded + rhs.indexesAdded(),</span>
<span class="fc" id="L648">				this.indexesRemoved + rhs.indexesRemoved(),</span>
<span class="fc" id="L649">				this.constraintsAdded + rhs.constraintsAdded(),</span>
<span class="fc" id="L650">				this.constraintsRemoved + rhs.constraintsRemoved()</span>
			);
		}
	}

	/**
	 * Something that can be executed from withing a catalog based migration.
	 */
	interface Operation {

		/**
		 * Creates a new drop operation
		 *
		 * @param name    The name of the item to drop
		 * @param ifExits should it be an idempotent operation or not?
		 * @return Ongoing definition
		 */
		static OperationBuilder&lt;DropOperation&gt; drop(Name name, boolean ifExits) {
<span class="fc" id="L668">			return new DefaultOperationBuilder&lt;DropOperation&gt;(Operator.DROP).drop(name, ifExits);</span>
		}

		/**
		 * Creates a new create operation
		 *
		 * @param name        The name of the item to create
		 * @param ifNotExists should it be an idempotent operation or not?
		 * @return Ongoing definition
		 */
		static OperationBuilder&lt;CreateOperation&gt; create(Name name, boolean ifNotExists) {
<span class="fc" id="L679">			return new DefaultOperationBuilder&lt;CreateOperation&gt;(Operator.CREATE).create(name, ifNotExists);</span>
		}

		/**
		 * Creates a new drop operation
		 *
		 * @param item    The item to create
		 * @param ifExits should it be an idempotent operation or not?
		 * @return Ongoing definition
		 */
		static DropOperation drop(CatalogItem&lt;?&gt; item, boolean ifExits) {
<span class="fc" id="L690">			return new DefaultOperationBuilder&lt;DropOperation&gt;(Operator.DROP).drop(item, ifExits);</span>
		}

		/**
		 * Creates a new create operation
		 *
		 * @param item        The item to drop
		 * @param ifNotExists should it be an idempotent operation or not?
		 * @return Ongoing definition
		 */
		static CreateOperation create(CatalogItem&lt;?&gt; item, boolean ifNotExists) {
<span class="fc" id="L701">			return new DefaultOperationBuilder&lt;CreateOperation&gt;(Operator.CREATE).create(item, ifNotExists);</span>
		}

		/**
		 * Creates a new {@link ApplyOperation}. This operation is potentially destructive. It will load all supported
		 * item types from the database, drop them and eventually create the content of the catalog.
		 *
		 * @return The operation ready to apply.
		 */
		static ApplyOperation apply(MigrationVersion definedAt) {
<span class="fc" id="L711">			return new DefaultApplyOperation(definedAt);</span>
		}

		/**
		 * Create a new {@link VerifyOperation}.
		 *
		 * @param useCurrent Use {@literal true} to verify / assert the current version, use {@literal false} to verify the previous.
		 * @return The operation ready to apply.
		 */
		static VerifyBuilder verify(boolean useCurrent) {
<span class="fc" id="L721">			return new DefaultOperationBuilder&lt;&gt;(null).verify(useCurrent);</span>
		}

		/**
		 * Executes this operation in the given context.
		 *
		 * @param context the context in which to execute this operation
		 */
		Counters execute(OperationContext context);
	}

	/**
	 * An operation that requires a version to be executed.
	 */
	interface VersionSpecificOperation extends Operation {

		/**
		 * @return the version at which this operation has been defined
		 */
		MigrationVersion getDefinedAt();
	}

	/**
	 * An operation that requires an item to be executed.
	 */
	interface ItemSpecificOperation extends Operation {

		/**
		 * @return an optional reference to the item that is subject to this operation
		 */
		Optional&lt;Name&gt; getReference();

		/**
		 * @return an optional local item.
		 */
		@SuppressWarnings(&quot;squid:S1452&quot;) // Generic items, this is exactly what we want here
		Optional&lt;CatalogItem&lt;?&gt;&gt; getLocalItem();
	}

	/**
	 * An operation that creates an item from the catalog inside the database.
	 */
	interface CreateOperation extends VersionSpecificOperation, ItemSpecificOperation {
	}

	/**
	 * An operation that drops an item from the catalog from the database.
	 */
	interface DropOperation extends VersionSpecificOperation, ItemSpecificOperation {
	}

	/**
	 * This operation loads all supported item types from the database, drops them and then creates all items of the local catalog.
	 */
	interface ApplyOperation extends VersionSpecificOperation {
	}

	/**
	 * This operation takes the current catalog and checks whether all items in the version second to last are
	 * defined in the same or equivalent fashion in the database or if both this catalog or the database are empty. The
	 * assertion is done before the most recent version so that - if necessary - all create and drop operations can be
	 * safely applied. Thus, you can even assert an empty catalog. This behaviour can be switched to using the current
	 * version by using the appropriate argument to builder method.
	 */
	interface VerifyOperation extends VersionSpecificOperation {

		/**
		 * @return {@literal true} if the current version should be verified, defaults to {@literal false}
		 */
		boolean useCurrent();

		/**
		 * @return {@literal true} if the equivalent catalogs are allowed, defaults to {@literal true}
		 */
		boolean allowEquivalent();
	}

	/**
	 * Specifies the version in which the item that is dealt with has been reference
	 *
	 * @param &lt;T&gt; The type of operation to build
	 */
	interface OperationBuilder&lt;T extends Operation&gt; {

		T with(MigrationVersion version);
	}

	/**
	 * Specifies the version at which verification should take place.
	 */
	interface TerminalVerifyBuilder {
		VerifyOperation at(MigrationVersion version);
	}

	/**
	 * Allows configuring whether equivalent but not identical catalogs are allowed
	 */
	interface VerifyBuilder extends TerminalVerifyBuilder {

		TerminalVerifyBuilder allowEquivalent(boolean allowEquivalent);
	}

	private static class DefaultOperationBuilder&lt;T extends Operation&gt; implements OperationBuilder&lt;T&gt;, VerifyBuilder {

		private final Operator operator;

		private Name reference;

		private CatalogItem&lt;?&gt; item;

		private boolean idempotent;

		private boolean useCurrent;

<span class="fc" id="L835">		private boolean allowEquivalent = true;</span>

<span class="fc" id="L837">		DefaultOperationBuilder(final Operator operator) {</span>
<span class="fc" id="L838">			this.operator = operator;</span>
<span class="fc" id="L839">		}</span>

		@SuppressWarnings({ &quot;HiddenField&quot; })
		OperationBuilder&lt;T&gt; drop(Name reference, boolean ifExits) {

<span class="fc" id="L844">			this.reference = reference;</span>
<span class="fc" id="L845">			this.idempotent = ifExits;</span>
<span class="fc" id="L846">			return this;</span>
		}

		@SuppressWarnings({ &quot;HiddenField&quot; })
		OperationBuilder&lt;T&gt; create(Name reference, boolean ifNotExists) {

<span class="fc" id="L852">			this.reference = reference;</span>
<span class="fc" id="L853">			this.idempotent = ifNotExists;</span>
<span class="fc" id="L854">			return this;</span>
		}

		@SuppressWarnings({ &quot;HiddenField&quot; })
		DropOperation drop(CatalogItem&lt;?&gt; item, boolean ifExits) {

<span class="fc" id="L860">			this.item = item;</span>
<span class="fc" id="L861">			this.idempotent = ifExits;</span>
<span class="fc" id="L862">			return new DefaultDropOperation(null, reference, item, idempotent);</span>
		}

		@SuppressWarnings({ &quot;HiddenField&quot; })
		CreateOperation create(CatalogItem&lt;?&gt; item, boolean ifNotExists) {

<span class="fc" id="L868">			this.item = item;</span>
<span class="fc" id="L869">			this.idempotent = ifNotExists;</span>
<span class="fc" id="L870">			return new DefaultCreateOperation(null, reference, item, idempotent);</span>
		}

		@SuppressWarnings({ &quot;HiddenField&quot; })
		VerifyBuilder verify(boolean useCurrent) {

<span class="fc" id="L876">			this.useCurrent = useCurrent;</span>
<span class="fc" id="L877">			return this;</span>
		}

		@SuppressWarnings({ &quot;HiddenField&quot; })
		@Override
		public TerminalVerifyBuilder allowEquivalent(boolean allowEquivalent) {

<span class="fc" id="L884">			this.allowEquivalent = allowEquivalent;</span>
<span class="fc" id="L885">			return this;</span>
		}

		@Override
		public VerifyOperation at(MigrationVersion version) {
<span class="fc" id="L890">			return new DefaultVerifyOperation(useCurrent, allowEquivalent, version);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public T with(MigrationVersion version) {

<span class="fc bfc" id="L897" title="All 2 branches covered.">			if (this.operator == Operator.DROP) {</span>
<span class="fc" id="L898">				return (T) new DefaultDropOperation(version, reference, item, idempotent);</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">			} else if (this.operator == Operator.CREATE) {</span>
<span class="fc" id="L900">				return (T) new DefaultCreateOperation(version, reference, item, idempotent);</span>
			} else {
<span class="nc" id="L902">				throw new UnsupportedOperationException();</span>
			}
		}
	}

	/**
	 * Some state for all operations working on a specific item defined by a named reference.
	 */
	private abstract static class AbstractItemBasedOperation
		implements VersionSpecificOperation, ItemSpecificOperation {

		protected final MigrationVersion definedAt;

		protected final Name reference;

		protected final CatalogItem&lt;?&gt; localItem;

		protected final boolean idempotent;

		AbstractItemBasedOperation(MigrationVersion definedAt, Name reference, CatalogItem&lt;?&gt; localItem,
<span class="fc" id="L922">			boolean idempotent) {</span>

<span class="fc bfc" id="L924" title="All 4 branches covered.">			if (definedAt == null &amp;&amp; localItem == null) {</span>
<span class="fc" id="L925">				throw new IllegalArgumentException(&quot;Without a version, a concrete, local item is required.&quot;);</span>
			}
<span class="fc bfc" id="L927" title="All 4 branches covered.">			if (reference != null &amp;&amp; localItem != null) {</span>
<span class="fc" id="L928">				throw new IllegalArgumentException(&quot;Either reference or item is required, not both.&quot;);</span>
			}

<span class="fc" id="L931">			this.definedAt = definedAt;</span>
<span class="fc" id="L932">			this.reference = reference;</span>
<span class="fc" id="L933">			this.localItem = localItem;</span>
<span class="fc" id="L934">			this.idempotent = idempotent;</span>
<span class="fc" id="L935">		}</span>

		@SuppressWarnings(&quot;squid:S1452&quot;) // Generic items, this is exactly what we want here
		CatalogItem&lt;?&gt; getRequiredItem(VersionedCatalog catalog) {

			// I want Java9+ and better optionals, so that I can or them
<span class="fc bfc" id="L941" title="All 2 branches covered.">			if (this.localItem != null) {</span>
<span class="fc" id="L942">				return this.localItem;</span>
			}

<span class="fc" id="L945">			return catalog.getItem(reference, definedAt).orElseThrow(() -&gt; new MigrationsException(</span>
<span class="fc" id="L946">				String.format(&quot;An item named '%s' has not been defined as of version %s.&quot;, reference.getValue(),</span>
<span class="fc" id="L947">					definedAt.getValue())));</span>
		}

		@Override
		public MigrationVersion getDefinedAt() {
<span class="nc" id="L952">			return definedAt;</span>
		}

		@Override
		public Optional&lt;Name&gt; getReference() {
<span class="fc" id="L957">			return Optional.ofNullable(reference);</span>
		}

		@Override
		public Optional&lt;CatalogItem&lt;?&gt;&gt; getLocalItem() {
<span class="fc" id="L962">			return Optional.ofNullable(localItem);</span>
		}
	}

	/**
	 * Executes creates.
	 */
	static final class DefaultCreateOperation extends AbstractItemBasedOperation implements CreateOperation {

		DefaultCreateOperation(MigrationVersion definedAt, Name reference, CatalogItem&lt;?&gt; item, boolean idempotent) {
<span class="fc" id="L972">			super(definedAt, reference, item, idempotent);</span>
<span class="fc" id="L973">		}</span>

		@Override
		public Counters execute(OperationContext context) {

<span class="fc" id="L978">			QueryRunner queryRunner = context.queryRunner;</span>
<span class="fc" id="L979">			CatalogItem&lt;?&gt; item = getRequiredItem(context.catalog);</span>
<span class="fc" id="L980">			Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer = Renderer.get(Renderer.Format.CYPHER, item);</span>
<span class="fc" id="L981">			RenderConfig config = RenderConfig.create()</span>
<span class="fc" id="L982">				.idempotent(idempotent)</span>
<span class="fc" id="L983">				.forVersionAndEdition(context.version, context.edition);</span>

<span class="fc bfc" id="L985" title="All 4 branches covered.">			if (idempotent &amp;&amp; !context.version.hasIdempotentOperations()) {</span>
<span class="fc" id="L986">				config = config.ignoreName();</span>
<span class="fc" id="L987">				return createIfNotExists(context, item, queryRunner, renderer, config);</span>
			} else {
<span class="fc" id="L989">				return Counters.of(queryRunner.run(renderer.render(item, config)).consume().counters());</span>
			}
		}

		private Counters createIfNotExists(OperationContext context, CatalogItem&lt;?&gt; item, QueryRunner queryRunner,
			Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer, RenderConfig config) {

			try {
<span class="fc" id="L997">				return Counters.of(queryRunner.run(renderer.render(item, config)).consume().counters());</span>
<span class="fc" id="L998">			} catch (Neo4jException e) {</span>
				// Directly throw anything that can't match
<span class="fc bfc" id="L1000" title="All 2 branches covered.">				if (!Neo4jCodes.CODES_FOR_EXISTING_CONSTRAINT.contains(e.code())) {</span>
<span class="fc" id="L1001">					throw e;</span>
				}

				// Make sure the thing actually is there.
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">				List&lt;CatalogItem&lt;?&gt;&gt; items = item instanceof Constraint</span>
<span class="fc" id="L1006">					? queryRunner.run(context.version.getShowConstraints()).list(Constraint::parse)</span>
<span class="pc" id="L1007">					: queryRunner.run(context.version.getShowIndexes()).list(Index::parse);</span>

				// If there are no constraints there at all, something fishy is going on for sure
				// otherwise, there must now an equivalent version of it
<span class="pc bpc" id="L1011" title="1 of 4 branches missed.">				if (items.isEmpty() || items.stream().noneMatch(existingItem -&gt; existingItem.isEquivalentTo(item))) {</span>
<span class="fc" id="L1012">					throw e;</span>
				}

			}
<span class="fc" id="L1016">			return Counters.empty();</span>
		}
	}

	/**
	 * Executes drops.
	 */
	static final class DefaultDropOperation extends AbstractItemBasedOperation implements DropOperation {

		DefaultDropOperation(MigrationVersion definedAt, Name reference, CatalogItem&lt;?&gt; item, boolean idempotent) {
<span class="fc" id="L1026">			super(definedAt, reference, item, idempotent);</span>
<span class="fc" id="L1027">		}</span>

		@Override
		public Counters execute(OperationContext context) {

<span class="fc" id="L1032">			QueryRunner queryRunner = context.queryRunner;</span>
<span class="fc" id="L1033">			CatalogItem&lt;?&gt; item = getRequiredItem(context.catalog);</span>
<span class="fc" id="L1034">			Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer = Renderer.get(Renderer.Format.CYPHER, item);</span>
<span class="fc" id="L1035">			RenderConfig config = RenderConfig.drop()</span>
<span class="fc" id="L1036">				.idempotent(idempotent)</span>
<span class="fc" id="L1037">				.forVersionAndEdition(context.version, context.edition);</span>

<span class="fc bfc" id="L1039" title="All 4 branches covered.">			if (idempotent &amp;&amp; !context.version.hasIdempotentOperations()) {</span>
<span class="fc" id="L1040">				config = config.ignoreName();</span>
<span class="fc" id="L1041">				return drop(context, item, queryRunner, renderer, config, true);</span>
			} else {
<span class="fc" id="L1043">				return Counters.of(queryRunner.run(renderer.render(item, config)).consume().counters());</span>
			}
		}

		private Counters drop(OperationContext context, CatalogItem&lt;?&gt; item, QueryRunner queryRunner,
			Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer,
			RenderConfig config, boolean fallbackToPrior) {

			try {
<span class="fc" id="L1052">				return Counters.of(queryRunner.run(renderer.render(item, config)).consume().counters());</span>
<span class="fc" id="L1053">			} catch (Neo4jException e) {</span>
				// Directly throw anything that can't match
<span class="fc bfc" id="L1055" title="All 2 branches covered.">				if (!Neo4jCodes.CONSTRAINT_DROP_FAILED.equals(e.code())) {</span>
<span class="fc" id="L1056">					throw e;</span>
				}

<span class="pc bpc" id="L1059" title="3 of 4 branches missed.">				if (!(item instanceof Constraint || item instanceof Index)) {</span>
<span class="nc" id="L1060">					throw new IllegalStateException(&quot;Item type &quot; + item.getClass() + &quot; not supported&quot;);</span>
				}

				// Make sure the thing actually not there.
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">				List&lt;CatalogItem&lt;?&gt;&gt; items = item instanceof Constraint</span>
<span class="fc" id="L1065">					? queryRunner.run(context.version.getShowConstraints()).list(Constraint::parse)</span>
<span class="pc" id="L1066">					: queryRunner.run(context.version.getShowIndexes()).list(Index::parse);</span>

<span class="fc bfc" id="L1068" title="All 2 branches covered.">				if (items.isEmpty()) {</span>
<span class="fc" id="L1069">					return Counters.empty();</span>
				}

<span class="fc bfc" id="L1072" title="All 2 branches covered.">				if (items.stream().anyMatch(existingIndex -&gt; existingIndex.isEquivalentTo(item))) {</span>
<span class="fc" id="L1073">					throw e;</span>
				}

<span class="fc bfc" id="L1076" title="All 4 branches covered.">				if (!fallbackToPrior || getLocalItem().isPresent()) {</span>
<span class="fc" id="L1077">					return Counters.empty();</span>
				}

				// If it has been defined in an older version users might have redefined it in this version,
				// such that couldn't have been dropped
<span class="fc" id="L1082">				return context.catalog.getItemPriorTo(reference, definedAt)</span>
<span class="fc" id="L1083">						.filter(</span>
<span class="fc" id="L1084">								v -&gt; items.stream().anyMatch(existingIndex -&gt; existingIndex.isEquivalentTo(v)))</span>
<span class="fc" id="L1085">						.map(olderItem -&gt; drop(context, olderItem, queryRunner, renderer, config, false))</span>
<span class="fc" id="L1086">						.orElseGet(Counters::empty);</span>
			}
		}
	}

	/**
	 * Default implementation of verification.
	 */
	static final class DefaultVerifyOperation implements VerifyOperation {

		private final boolean useCurrent;
		private final boolean allowEquivalent;
		private final MigrationVersion definedAt;

<span class="fc" id="L1100">		DefaultVerifyOperation(boolean useCurrent, boolean allowEquivalent, MigrationVersion definedAt) {</span>
<span class="fc" id="L1101">			this.useCurrent = useCurrent;</span>
<span class="fc" id="L1102">			this.definedAt = definedAt;</span>
<span class="fc" id="L1103">			this.allowEquivalent = allowEquivalent;</span>
<span class="fc" id="L1104">		}</span>

		@Override
		public Counters execute(OperationContext context) {

<span class="fc" id="L1109">			QueryRunner queryRunner = context.queryRunner;</span>
			// Get all the constraints
<span class="fc" id="L1111">			Catalog databaseCatalog = DatabaseCatalog.of(context.version, queryRunner);</span>
<span class="fc" id="L1112">			VersionedCatalog currentCatalog = context.catalog;</span>

<span class="fc" id="L1114">			CatalogDiff diff = CatalogDiff.between(databaseCatalog,</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">				useCurrent ?</span>
<span class="fc" id="L1116">					currentCatalog.getCatalogAt(definedAt) :</span>
<span class="fc" id="L1117">					currentCatalog.getCatalogPriorTo(definedAt));</span>

<span class="fc bfc" id="L1119" title="All 2 branches covered.">			if (diff.identical()) {</span>
<span class="fc" id="L1120">				LOGGER.log(Level.FINE, &quot;Database schema and catalog are identical.&quot;);</span>
<span class="fc bfc" id="L1121" title="All 4 branches covered.">			} else if (diff.equivalent() &amp;&amp; allowEquivalent) {</span>
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">				if (LOGGER.isLoggable(Level.WARNING)) {</span>

<span class="fc" id="L1124">					StringBuilder message = new StringBuilder();</span>
<span class="fc" id="L1125">					Collection&lt;CatalogItem&lt;?&gt;&gt; itemsOnlyInRight = diff.getItemsOnlyInRight();</span>
<span class="fc" id="L1126">					message.append(</span>
						&quot;Items in the database are not identical to items in the schema catalog. The following items have different names but an equivalent definition:&quot;);
<span class="fc" id="L1128">					diff.getItemsOnlyInLeft().forEach(item -&gt; itemsOnlyInRight.stream()</span>
<span class="fc" id="L1129">						.filter(item::isEquivalentTo)</span>
<span class="fc" id="L1130">						.findFirst()</span>
<span class="fc" id="L1131">						.ifPresent(equivalentItem -&gt;</span>
<span class="fc" id="L1132">							message</span>
<span class="fc" id="L1133">								.append(System.lineSeparator())</span>
<span class="fc" id="L1134">								.append(&quot;* Database item `&quot;)</span>
<span class="fc" id="L1135">								.append(item.getName().getValue())</span>
<span class="fc" id="L1136">								.append(&quot;` matches catalog item `&quot;)</span>
<span class="fc" id="L1137">								.append(equivalentItem.getName().getValue())</span>
<span class="fc" id="L1138">								.append(&quot;`&quot;)</span>
						));

<span class="fc" id="L1141">					LOGGER.log(Level.WARNING, message.toString());</span>
<span class="fc" id="L1142">				}</span>
			} else {
<span class="fc bfc" id="L1144" title="All 2 branches covered.">				throw new VerificationFailedException(diff.equivalent() ?</span>
<span class="fc" id="L1145">					&quot;Database schema and the catalog are equivalent but the verification requires them to be identical.&quot; :</span>
<span class="fc" id="L1146">					&quot;Catalogs are neither identical nor equivalent.&quot;);</span>
			}

<span class="fc" id="L1149">			return Counters.empty();</span>
		}

		@Override
		public boolean useCurrent() {
<span class="fc" id="L1154">			return useCurrent;</span>
		}

		@Override
		public boolean allowEquivalent() {
<span class="fc" id="L1159">			return allowEquivalent;</span>
		}

		@Override
		public MigrationVersion getDefinedAt() {
<span class="fc" id="L1164">			return definedAt;</span>
		}
	}

	static final class VerificationFailedException extends RuntimeException {

		private static final long serialVersionUID = 6481650211840799118L;

		VerificationFailedException(String message) {
<span class="fc" id="L1173">			super(message);</span>
<span class="fc" id="L1174">		}</span>
	}

	/**
	 * Drops everything from the database catalog, adds everything from the migrations catalog.
	 */
	static final class DefaultApplyOperation implements ApplyOperation {

		private final MigrationVersion definedAt;

<span class="fc" id="L1184">		DefaultApplyOperation(MigrationVersion definedAt) {</span>
<span class="fc" id="L1185">			this.definedAt = definedAt;</span>
<span class="fc" id="L1186">		}</span>

		@Override
		public Counters execute(OperationContext context) {

<span class="fc" id="L1191">			QueryRunner queryRunner = context.queryRunner;</span>
			// Get all the constraints
<span class="fc" id="L1193">			Catalog databaseCatalog = DatabaseCatalog.of(context.version, queryRunner);</span>

			// Make them go away
<span class="fc" id="L1196">			RenderConfig dropConfig = RenderConfig.drop()</span>
<span class="fc" id="L1197">				.forVersionAndEdition(context.version, context.edition);</span>
<span class="fc" id="L1198">			AtomicInteger constraintsRemoved = new AtomicInteger(0);</span>
<span class="fc" id="L1199">			AtomicInteger indexesRemoved = new AtomicInteger(0);</span>
<span class="fc" id="L1200">			databaseCatalog.getItems().forEach(catalogItem -&gt; {</span>
<span class="fc" id="L1201">				Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer = Renderer.get(Renderer.Format.CYPHER, catalogItem);</span>
<span class="fc" id="L1202">				SummaryCounters counters = queryRunner.run(renderer.render(catalogItem, dropConfig)).consume()</span>
<span class="fc" id="L1203">					.counters();</span>
<span class="fc" id="L1204">				constraintsRemoved.addAndGet(counters.constraintsRemoved());</span>
<span class="fc" id="L1205">				indexesRemoved.addAndGet(counters.indexesRemoved());</span>
<span class="fc" id="L1206">			});</span>

			// Add the new ones
<span class="fc" id="L1209">			RenderConfig createConfig = RenderConfig.create()</span>
<span class="fc" id="L1210">				.forVersionAndEdition(context.version, context.edition);</span>
<span class="fc" id="L1211">			AtomicInteger constraintsAdded = new AtomicInteger(0);</span>
<span class="fc" id="L1212">			AtomicInteger indexesAdded = new AtomicInteger(0);</span>
<span class="fc" id="L1213">			context.catalog.getCatalogAt(definedAt).getItems().forEach(item -&gt; {</span>
<span class="fc" id="L1214">				Renderer&lt;CatalogItem&lt;?&gt;&gt; renderer = Renderer.get(Renderer.Format.CYPHER, item);</span>
<span class="fc" id="L1215">				SummaryCounters counters = queryRunner.run(renderer.render(item, createConfig)).consume().counters();</span>
<span class="fc" id="L1216">				constraintsAdded.addAndGet(counters.constraintsAdded());</span>
<span class="fc" id="L1217">				indexesAdded.addAndGet(counters.indexesAdded());</span>
<span class="fc" id="L1218">			});</span>

<span class="fc" id="L1220">			return Counters.of(indexesAdded.get(), indexesRemoved.get(), constraintsAdded.get(),</span>
<span class="fc" id="L1221">				constraintsRemoved.get());</span>
		}

		@Override
		public MigrationVersion getDefinedAt() {
<span class="nc" id="L1226">			return definedAt;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>