<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Migrations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Neo4j Migrations (Core)</a> &gt; <a href="index.source.html" class="el_package">ac.simons.neo4j.migrations.core</a> &gt; <span class="el_source">Migrations.java</span></div><h1>Migrations.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ac.simons.neo4j.migrations.core;

import ac.simons.neo4j.migrations.core.MigrationChain.ChainBuilderMode;
import ac.simons.neo4j.migrations.core.ValidationResult.Outcome;
import ac.simons.neo4j.migrations.core.catalog.Catalog;
import ac.simons.neo4j.migrations.core.catalog.Constraint;
import ac.simons.neo4j.migrations.core.catalog.RenderConfig;
import ac.simons.neo4j.migrations.core.catalog.Renderer;
import ac.simons.neo4j.migrations.core.internal.Neo4jVersion;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.neo4j.driver.Driver;
import org.neo4j.driver.Result;
import org.neo4j.driver.Session;
import org.neo4j.driver.Values;
import org.neo4j.driver.exceptions.NoSuchRecordException;
import org.neo4j.driver.exceptions.ServiceUnavailableException;
import org.neo4j.driver.summary.SummaryCounters;
import org.neo4j.driver.types.Node;

/**
 * Main entry to Neo4j Migrations
 *
 * @author Michael J. Simons
 * @since 0.0.1
 */
public final class Migrations {

<span class="fc" id="L53">	static final Logger LOGGER = Logger.getLogger(Migrations.class.getName());</span>

	private static final String PROPERTY_MIGRATION_VERSION = &quot;version&quot;;
	private static final String PROPERTY_MIGRATION_TARGET = &quot;migrationTarget&quot;;
	private static final String PROPERTY_MIGRATION_DESCRIPTION = &quot;description&quot;;

<span class="fc" id="L59">	static final Constraint UNIQUE_VERSION =</span>
<span class="fc" id="L60">		Constraint.forNode(&quot;__Neo4jMigration&quot;)</span>
<span class="fc" id="L61">			.named(&quot;unique_version___Neo4jMigration&quot;)</span>
<span class="fc" id="L62">			.unique(PROPERTY_MIGRATION_VERSION, PROPERTY_MIGRATION_TARGET);</span>

	private final MigrationsConfig config;
	private final Driver driver;
	private final MigrationContext context;
	private final DiscoveryService discoveryService;
	private final ChainBuilder chainBuilder;

	@SuppressWarnings(&quot;squid:S3077&quot;)
	private volatile List&lt;Migration&gt; resolvedMigrations;
	@SuppressWarnings(&quot;squid:S3077&quot;)
	private volatile Map&lt;LifecyclePhase, List&lt;Callback&gt;&gt; resolvedCallbacks;

<span class="fc" id="L75">	private final AtomicBoolean beforeFirstUseHasBeenCalled = new AtomicBoolean(false);</span>

	/**
	 * Creates a {@link Migrations migrations instance} ready to used with the given configuration over the connection
	 * defined by the {@link Driver driver}.
	 *
	 * @param config The configuration to use
	 * @param driver The connection
	 */
<span class="fc" id="L84">	public Migrations(MigrationsConfig config, Driver driver) {</span>

<span class="fc" id="L86">		this.config = config;</span>
<span class="fc" id="L87">		this.driver = driver;</span>

<span class="fc" id="L89">		this.discoveryService = new DiscoveryService(this.config.getMigrationClassesDiscoverer(), this.config.getResourceScanner());</span>
<span class="fc" id="L90">		this.chainBuilder = new ChainBuilder();</span>

<span class="fc" id="L92">		this.context = new DefaultMigrationContext(this.config, this.driver);</span>
<span class="fc" id="L93">	}</span>

	private List&lt;Migration&gt; getMigrations() {

<span class="fc" id="L97">		List&lt;Migration&gt; availableMigrations = this.resolvedMigrations;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if (availableMigrations == null) {</span>
<span class="fc" id="L99">			synchronized (this) {</span>
<span class="fc" id="L100">				availableMigrations = this.resolvedMigrations;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">				if (availableMigrations == null) {</span>
<span class="fc" id="L102">					this.resolvedMigrations = discoveryService.findMigrations(this.context);</span>
<span class="fc" id="L103">					availableMigrations = this.resolvedMigrations;</span>
				}
<span class="fc" id="L105">			}</span>
		}
<span class="fc" id="L107">		return availableMigrations;</span>
	}

	private Map&lt;LifecyclePhase, List&lt;Callback&gt;&gt; getCallbacks() {

<span class="fc" id="L112">		Map&lt;LifecyclePhase, List&lt;Callback&gt;&gt; availableCallbacks = this.resolvedCallbacks;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">		if (availableCallbacks == null) {</span>
<span class="fc" id="L114">			synchronized (this) {</span>
<span class="fc" id="L115">				availableCallbacks = this.resolvedCallbacks;</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">				if (availableCallbacks == null) {</span>
<span class="fc" id="L117">					this.resolvedCallbacks = discoveryService.findCallbacks(this.context);</span>
<span class="fc" id="L118">					availableCallbacks = this.resolvedCallbacks;</span>
				}
<span class="fc" id="L120">			}</span>
		}
<span class="fc" id="L122">		return availableCallbacks;</span>
	}

	/**
	 * @return Information about the connection when migrations are applied, validated and so on.
	 * @see MigrationContext#getConnectionDetails()
	 * @since 1.4.0
	 */
	public ConnectionDetails getConnectionDetails() {
<span class="fc" id="L131">		return context.getConnectionDetails();</span>
	}

	/**
	 * Returns information about the context, the database, all applied and all pending applications.
	 *
	 * @return The chain of migrations.
	 * @throws ServiceUnavailableException in case the driver is not connected
	 * @throws MigrationsException         for everything caused by failing migrations
	 * @see #info(ChainBuilderMode)
	 * @since 0.0.4
	 */
	public MigrationChain info() {

<span class="fc" id="L145">		return executeWithinLock(() -&gt; chainBuilder.buildChain(context, this.getMigrations()),</span>
			LifecyclePhase.BEFORE_INFO, LifecyclePhase.AFTER_INFO);
	}

	/**
	 * Returns information about the context, the database, all applied and all pending applications.
	 *
	 * @param infoCmd Specify how the chain should be computed
	 * @return The chain of migrations.
	 * @throws ServiceUnavailableException in case the driver is not connected
	 * @throws MigrationsException         for everything caused by failing migrations
	 * @since 1.4.0
	 */
	public MigrationChain info(ChainBuilderMode infoCmd) {

<span class="fc" id="L160">		return executeWithinLock(() -&gt; chainBuilder.buildChain(context, this.getMigrations(), false,</span>
				infoCmd),
			LifecyclePhase.BEFORE_INFO, LifecyclePhase.AFTER_INFO);
	}

	/**
	 * Applies all discovered Neo4j migrations. Migrations can either be classes implementing {@link JavaBasedMigration}
	 * or Cypher script migrations that are on the classpath or filesystem.
	 *
	 * @return The last applied migration (if any)
	 * @throws ServiceUnavailableException in case the driver is not connected
	 * @throws MigrationsException         for everything caused by failing migrations
	 * @since 0.0.1
	 */
	public Optional&lt;MigrationVersion&gt; apply() {

<span class="fc" id="L176">		return executeWithinLock(() -&gt; {</span>
<span class="fc" id="L177">			apply0(this.getMigrations());</span>
<span class="fc" id="L178">			return getLastAppliedVersion();</span>
		}, LifecyclePhase.BEFORE_MIGRATE, LifecyclePhase.AFTER_MIGRATE);
	}

	/**
	 * Cleans the {@link MigrationsConfig#getOptionalSchemaDatabase() selected schema database}. If there is no schema
	 * database selected, looks in the {@link MigrationsConfig#getOptionalDatabase() target database.} If this isn't
	 * configured as well, the users home database will be searched for
	 * &lt;ol&gt;
	 * &lt;li&gt;Migration chains (those are the nodes containing information about the applied migrations&lt;/li&gt;
	 * &lt;li&gt;Any log from this tool&lt;/li&gt;
	 * &lt;li&gt;Any constraints created by this tool&lt;/li&gt;
	 * &lt;/ol&gt;
	 * and will delete and drop them in that order. This is a &lt;strong&gt;destructive&lt;/strong&gt; operation, so make sure not
	 * to apply it to your production database without thinking at least twice. It cannot be undone via Neo4j-Migrations.
	 *
	 * @param all Set to {@literal true} to remove all constructs created by Neo4j-Migrations, set to {@literal false} to
	 *            remove all the migration chain for the selected or automatically determined target database.
	 * @return The result of cleaning the database.
	 * @throws ServiceUnavailableException in case the driver is not connected
	 * @throws MigrationsException         for everything caused due to schema objects not deletable
	 * @since 1.1.0
	 */
	public CleanResult clean(boolean all) {

<span class="fc" id="L203">		Optional&lt;String&gt; optionalMigrationTarget = config.getMigrationTargetIn(context);</span>
<span class="fc" id="L204">		DeletedChainsWithCounters deletedChainsWithCounters</span>
<span class="fc" id="L205">			= executeWithinLock(() -&gt; clean0(optionalMigrationTarget, all), LifecyclePhase.BEFORE_CLEAN, LifecyclePhase.AFTER_CLEAN);</span>

<span class="fc" id="L207">		long nodesDeleted = deletedChainsWithCounters.counter.nodesDeleted();</span>
<span class="fc" id="L208">		long relationshipsDeleted = deletedChainsWithCounters.counter.relationshipsDeleted();</span>
<span class="fc" id="L209">		long constraintsRemoved = deletedChainsWithCounters.counter.constraintsRemoved() + deletedChainsWithCounters.additionalConstraintsRemoved;</span>
<span class="fc" id="L210">		long indexesRemoved = 0;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (all) {</span>
<span class="fc" id="L212">			SummaryCounters additionalCounters = new MigrationsLock(context).clean();</span>
<span class="fc" id="L213">			nodesDeleted += additionalCounters.nodesDeleted();</span>
<span class="fc" id="L214">			relationshipsDeleted += additionalCounters.relationshipsDeleted();</span>
<span class="fc" id="L215">			constraintsRemoved += additionalCounters.constraintsRemoved();</span>
<span class="fc" id="L216">			indexesRemoved += additionalCounters.indexesRemoved();</span>
		}

<span class="fc" id="L219">		return new CleanResult(config.getOptionalSchemaDatabase(), deletedChainsWithCounters.chainsDeleted, nodesDeleted,</span>
			relationshipsDeleted,
			constraintsRemoved, indexesRemoved);
	}

	static class DeletedChainsWithCounters {

		final List&lt;String&gt; chainsDeleted;
		final SummaryCounters counter;
		final long additionalConstraintsRemoved;

<span class="fc" id="L230">		DeletedChainsWithCounters(List&lt;String&gt; chainsDeleted, SummaryCounters counter) {</span>
<span class="fc" id="L231">			this.chainsDeleted = chainsDeleted;</span>
<span class="fc" id="L232">			this.counter = counter;</span>
<span class="fc" id="L233">			this.additionalConstraintsRemoved = 0L;</span>
<span class="fc" id="L234">		}</span>

<span class="fc" id="L236">		DeletedChainsWithCounters(DeletedChainsWithCounters source, long additionalConstraintsRemoved) {</span>
<span class="fc" id="L237">			this.chainsDeleted = source.chainsDeleted;</span>
<span class="fc" id="L238">			this.counter = source.counter;</span>
<span class="fc" id="L239">			this.additionalConstraintsRemoved = additionalConstraintsRemoved;</span>
<span class="fc" id="L240">		}</span>
	}

	private DeletedChainsWithCounters clean0(
		@SuppressWarnings(&quot;OptionalUsedAsFieldOrParameterType&quot;) Optional&lt;String&gt; migrationTarget,
		boolean all
	) {

<span class="fc" id="L248">		String query = &quot;&quot;</span>
			+ &quot;MATCH (n:__Neo4jMigration) &quot;
			+ &quot;WITH n, coalesce(n.migrationTarget, '&lt;default&gt;') as migrationTarget &quot;
			+ &quot;WHERE (migrationTarget = coalesce($migrationTarget,'&lt;default&gt;') OR $all)&quot;
			+ &quot;DETACH DELETE n &quot;
			+ &quot;RETURN DISTINCT migrationTarget &quot;
			+ &quot;ORDER BY migrationTarget ASC &quot;;

<span class="fc" id="L256">		try (Session session = context.getSchemaSession()) {</span>
<span class="fc" id="L257">			DeletedChainsWithCounters deletedChainsWithCounters = session.writeTransaction(tx -&gt; {</span>
<span class="fc" id="L258">				Result result = tx.run(query, Values.parameters(PROPERTY_MIGRATION_TARGET, migrationTarget.orElse(null), &quot;all&quot;, all));</span>
<span class="fc" id="L259">				return new DeletedChainsWithCounters(</span>
<span class="fc" id="L260">					result.list(r -&gt; r.get(PROPERTY_MIGRATION_TARGET).asString()),</span>
<span class="fc" id="L261">					result.consume().counters()</span>
				);
			});
<span class="fc" id="L264">			ConnectionDetails cd = context.getConnectionDetails();</span>
<span class="fc bfc" id="L265" title="All 4 branches covered.">			if (all &amp;&amp; HBD.is44OrHigher(cd)) {</span>

<span class="fc" id="L267">				Renderer&lt;Constraint&gt; renderer = Renderer.get(Renderer.Format.CYPHER, Constraint.class);</span>
<span class="fc" id="L268">				RenderConfig dropConfig = RenderConfig.drop()</span>
<span class="fc" id="L269">					.ifExists()</span>
<span class="fc" id="L270">					.forVersionAndEdition(cd.getServerVersion(), cd.getServerEdition());</span>

<span class="fc" id="L272">				return new DeletedChainsWithCounters(deletedChainsWithCounters,</span>
<span class="fc" id="L273">					session.run(renderer.render(UNIQUE_VERSION, dropConfig)).consume().counters().constraintsRemoved());</span>
			}

<span class="fc" id="L276">			return deletedChainsWithCounters;</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">		}</span>
	}

	/**
	 * Validates the database against the resolved migrations. A database is considered to be in a valid state when all
	 * resolved migrations have been applied (there are no more pending migrations). If a database is not yet fully migrated,
	 * it won't identify as {@link ValidationResult.Outcome#VALID} but it will indicate via {@link ValidationResult#needsRepair()} that
	 * it doesn't need repair. Applying the pending migrations via {@link #apply()} will bring the database into a valid state.
	 * Most other outcomes not valid need to be manually fix. One radical fix is calling {@link Migrations#clean(boolean)}
	 * with the same configuration.
	 *
	 * @return a validation result, with an outcome, a possible list of warnings and indicators if the database is in a valid state
	 * @since 1.2.0
	 */
	public ValidationResult validate() {

<span class="fc" id="L293">		return executeWithinLock(() -&gt; {</span>
<span class="fc" id="L294">			List&lt;Migration&gt; migrations = this.getMigrations();</span>
<span class="fc" id="L295">			Optional&lt;String&gt; targetDatabase = config.getOptionalSchemaDatabase();</span>
			try {
<span class="fc" id="L297">				MigrationChain migrationChain = new ChainBuilder(true).buildChain(context, migrations, true, ChainBuilderMode.COMPARE);</span>
<span class="fc" id="L298">				int numberOfAppliedMigrations = (int) migrationChain.getElements()</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">					.stream().filter(m -&gt; m.getState() == MigrationState.APPLIED)</span>
<span class="fc" id="L300">					.count();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">				if (migrations.size() == numberOfAppliedMigrations) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">					return new ValidationResult(targetDatabase, Outcome.VALID, numberOfAppliedMigrations == 0 ?</span>
<span class="fc" id="L303">						Collections.singletonList(&quot;No migrations resolved.&quot;) :</span>
<span class="fc" id="L304">						Collections.emptyList());</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">				} else if (migrations.size() &gt; numberOfAppliedMigrations) {</span>
<span class="fc" id="L306">					return new ValidationResult(targetDatabase, Outcome.INCOMPLETE_DATABASE, Collections.emptyList());</span>
				}
<span class="nc" id="L308">				return new ValidationResult(targetDatabase, Outcome.UNDEFINED, Collections.emptyList());</span>
<span class="fc" id="L309">			} catch (MigrationsException e) {</span>
<span class="fc" id="L310">				List&lt;String&gt; warnings = Collections.singletonList(e.getMessage());</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">				if (e.getCause() instanceof IndexOutOfBoundsException) {</span>
<span class="fc" id="L312">					return new ValidationResult(targetDatabase, Outcome.INCOMPLETE_MIGRATIONS, warnings);</span>
				}
<span class="fc" id="L314">				return new ValidationResult(targetDatabase, Outcome.DIFFERENT_CONTENT, warnings);</span>
			}
		}, LifecyclePhase.BEFORE_VALIDATE, LifecyclePhase.AFTER_VALIDATE);
	}

	/**
	 * Retrieves the local catalog, containing constraints and indexes.
	 *
	 * @return the local catalog
	 * @since 1.7.0
	 */
	public Catalog getLocalCatalog() {

		// Retrieving the migrations will initialize the local catalog
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (getMigrations().isEmpty()) {</span>
<span class="nc" id="L329">			return Catalog.empty();</span>
		}
<span class="fc" id="L331">		return this.context.getCatalog();</span>
	}

	/**
	 * Retrieves the database catalog
	 * @return the database catalog
	 * @since 1.7.0
	 */
	public Catalog getDatabaseCatalog() {

<span class="fc" id="L341">		return executeWithinLock(() -&gt; {</span>
<span class="fc" id="L342">			try (Session session = context.getSession()) {</span>
<span class="fc" id="L343">				Neo4jVersion neo4jVersion = Neo4jVersion.of(context.getConnectionDetails().getServerVersion());</span>
<span class="fc" id="L344">				return DatabaseCatalog.of(neo4jVersion, session);</span>
			}
		}, null, null);
	}

	/**
	 * @return the user agent for Neo4j-Migrations (given in the form {@literal name/version}).
	 * @since 1.2.1
	 */
	public static String getUserAgent() {
<span class="fc" id="L354">		return &quot;neo4j-migrations/&quot; + ProductVersion.getValue();</span>
	}

	private &lt;T&gt; T executeWithinLock(Supplier&lt;T&gt; executable, LifecyclePhase before, LifecyclePhase after) {

<span class="fc" id="L359">		driver.verifyConnectivity();</span>

<span class="fc" id="L361">		MigrationsLock lock = new MigrationsLock(this.context);</span>
		try {
<span class="fc" id="L363">			lock.lock();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">			if (beforeFirstUseHasBeenCalled.compareAndSet(false, true)) {</span>
<span class="fc" id="L365">				invokeCallbacks(LifecyclePhase.BEFORE_FIRST_USE);</span>
			}
			try {
<span class="fc" id="L368">				invokeCallbacks(before);</span>
<span class="fc" id="L369">				return executable.get();</span>
			} finally {
<span class="fc" id="L371">				invokeCallbacks(after);</span>
			}
		} finally {
			try {
<span class="fc" id="L375">				lock.unlock();</span>
<span class="fc" id="L376">			} catch (Exception e) {</span>
<span class="fc" id="L377">				LOGGER.log(Level.SEVERE, &quot;Could not unlock… Please check for residues (Nodes labeled `__Neo4jMigrationsLock`).&quot;);</span>
<span class="fc" id="L378">			}</span>
		}
	}

	/**
	 * @param phase can be {@literal null}, no callback will be involved then
	 */
	private void invokeCallbacks(LifecyclePhase phase) {

<span class="fc bfc" id="L387" title="All 2 branches covered.">		if (phase == null) {</span>
<span class="fc" id="L388">			return;</span>
		}

<span class="fc" id="L391">		LifecycleEvent event = new DefaultLifecycleEvent(phase, this.context);</span>
<span class="fc" id="L392">		this.getCallbacks().getOrDefault(phase, Collections.emptyList())</span>
<span class="fc" id="L393">			.forEach(callback -&gt; {</span>
				try {
<span class="fc" id="L395">					callback.on(event);</span>
<span class="fc" id="L396">				} catch (Exception e) {</span>
<span class="fc" id="L397">					throw new MigrationsException(&quot;Could not invoke &quot; + toString(callback, phase) + &quot;.&quot;, e);</span>
<span class="fc" id="L398">				}</span>
<span class="fc" id="L399">				LOGGER.log(Level.INFO, logMessageSupplier(callback, phase));</span>
<span class="fc" id="L400">			});</span>
<span class="fc" id="L401">	}</span>

	static Supplier&lt;String&gt; logMessageSupplier(Callback callback, LifecyclePhase phase) {

<span class="fc" id="L405">		return () -&gt; String.format(&quot;Invoked %s.&quot;, toString(callback, phase));</span>
	}

	static String toString(Callback callback, LifecyclePhase phase) {
<span class="fc" id="L409">		Optional&lt;String&gt; optionalDescription = callback.getOptionalDescription();</span>
<span class="fc" id="L410">		return optionalDescription</span>
<span class="fc" id="L411">			.map(d -&gt; String.format(&quot;\&quot;%s\&quot; %s&quot;, d, phase.readable()))</span>
<span class="fc" id="L412">			.orElseGet(() -&gt; String.format(&quot;%s callback&quot;, phase.toCamelCase()));</span>
	}

	private Optional&lt;MigrationVersion&gt; getLastAppliedVersion() {

<span class="fc" id="L417">		try (Session session = context.getSchemaSession()) {</span>
<span class="fc" id="L418">			Node lastMigration = session.readTransaction(tx -&gt;</span>
<span class="fc" id="L419">				tx.run(</span>
					&quot;MATCH (l:__Neo4jMigration) WHERE coalesce(l.migrationTarget,'&lt;default&gt;') = coalesce($migrationTarget,'&lt;default&gt;') AND NOT (l)-[:MIGRATED_TO]-&gt;(:__Neo4jMigration) RETURN l&quot;,
<span class="fc" id="L421">						Collections.singletonMap(PROPERTY_MIGRATION_TARGET, config.getMigrationTargetIn(context).orElse(null)))</span>
<span class="fc" id="L422">				.single().get(0).asNode());</span>

<span class="fc" id="L424">			String version = lastMigration.get(PROPERTY_MIGRATION_VERSION).asString();</span>
<span class="fc" id="L425">			String description = lastMigration.get(PROPERTY_MIGRATION_DESCRIPTION).asString();</span>

<span class="fc" id="L427">			return Optional.of(MigrationVersion.withValueAndDescription(version, description));</span>
<span class="fc" id="L428">		} catch (NoSuchRecordException e) {</span>
<span class="fc" id="L429">			return Optional.empty();</span>
		}
	}

	static void ensureConstraints(MigrationContext context) {

		// Composite unique constraints are not supported here
<span class="fc bfc" id="L436" title="All 2 branches covered.">		if (!HBD.is44OrHigher(context.getConnectionDetails())) {</span>
<span class="fc" id="L437">			return;</span>
		}

<span class="fc" id="L440">		ConnectionDetails cd = context.getConnectionDetails();</span>
<span class="fc" id="L441">		try (Session session = context.getSchemaSession()) {</span>
<span class="fc" id="L442">			Renderer&lt;Constraint&gt; renderer = Renderer.get(Renderer.Format.CYPHER, Constraint.class);</span>
<span class="fc" id="L443">			RenderConfig createConfig = RenderConfig.create().forVersionAndEdition(cd.getServerVersion(), cd.getServerEdition());</span>

<span class="fc" id="L445">			final String stmt = renderer.render(UNIQUE_VERSION, createConfig);</span>
<span class="pc" id="L446">			HBD.silentCreateConstraint(context.getConnectionDetails(), session, stmt, null, () -&gt; &quot;Could not create unique constraint for targeted migrations.&quot;);</span>
		}
<span class="fc" id="L448">	}</span>

	private void apply0(List&lt;Migration&gt; migrations) {

<span class="fc" id="L452">		ensureConstraints(context);</span>

<span class="fc" id="L454">		MigrationVersion previousVersion = getLastAppliedVersion()</span>
<span class="fc" id="L455">			.orElseGet(MigrationVersion::baseline);</span>

		// Validate and build the chain of migrations
<span class="fc" id="L458">		MigrationChain chain = chainBuilder.buildChain(context, migrations);</span>

<span class="fc" id="L460">		StopWatch stopWatch = new StopWatch();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">		for (Migration migration : migrations) {</span>

<span class="fc bfc" id="L463" title="All 4 branches covered.">			if (previousVersion != MigrationVersion.baseline() &amp;&amp; chain.isApplied(migration.getVersion().getValue())) {</span>
<span class="fc" id="L464">				LOGGER.log(Level.INFO, &quot;Skipping already applied migration {0}&quot;, toString(migration));</span>
<span class="fc" id="L465">				continue;</span>
			}
			try {
<span class="fc" id="L468">				stopWatch.start();</span>
<span class="fc" id="L469">				migration.apply(context);</span>
<span class="fc" id="L470">				long executionTime = stopWatch.stop();</span>
<span class="fc" id="L471">				previousVersion = recordApplication(chain.getUsername(), previousVersion, migration, executionTime);</span>

<span class="fc" id="L473">				LOGGER.log(Level.INFO, &quot;Applied migration {0}.&quot;, toString(migration));</span>
<span class="fc" id="L474">			} catch (MigrationsException e) {</span>
<span class="fc" id="L475">				throw e;</span>
<span class="fc" id="L476">			} catch (Exception e) {</span>
<span class="fc" id="L477">				throw new MigrationsException(&quot;Could not apply migration: &quot; + toString(migration) + &quot;.&quot;, e);</span>
			} finally {
<span class="fc" id="L479">				stopWatch.reset();</span>
			}
<span class="fc" id="L481">		}</span>
<span class="fc" id="L482">	}</span>

	private MigrationVersion recordApplication(String neo4jUser, MigrationVersion previousVersion, Migration appliedMigration,
		long executionTime) {

<span class="fc" id="L487">		try (Session session = context.getSchemaSession()) {</span>

<span class="fc" id="L489">			Optional&lt;String&gt; migrationTarget = context.getConfig().getMigrationTargetIn(context);</span>
<span class="fc" id="L490">			Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L491">			parameters.put(&quot;neo4jUser&quot;, neo4jUser);</span>
<span class="fc" id="L492">			parameters.put(&quot;previousVersion&quot;, previousVersion.getValue());</span>
<span class="fc" id="L493">			parameters.put(&quot;appliedMigration&quot;, toProperties(appliedMigration));</span>
<span class="fc" id="L494">			parameters.put(&quot;installedBy&quot;, config.getOptionalInstalledBy().map(Values::value).orElse(Values.NULL));</span>
<span class="fc" id="L495">			parameters.put(&quot;executionTime&quot;, executionTime);</span>
<span class="fc" id="L496">			parameters.put(PROPERTY_MIGRATION_TARGET, migrationTarget.orElse(null));</span>

<span class="fc" id="L498">			session.writeTransaction(t -&gt; {</span>
				String mergeOrMatchAndMaybeCreate;
<span class="fc bfc" id="L500" title="All 2 branches covered.">				if (migrationTarget.isPresent()) {</span>
<span class="fc" id="L501">					mergeOrMatchAndMaybeCreate = &quot;MERGE (p:__Neo4jMigration {version: $previousVersion, migrationTarget: $migrationTarget}) &quot;;</span>
				} else {
<span class="fc" id="L503">					Result result = t.run(</span>
						&quot;MATCH (p:__Neo4jMigration {version: $previousVersion}) WHERE p.migrationTarget IS NULL RETURN id(p) AS id&quot;,
<span class="fc" id="L505">						Values.parameters(&quot;previousVersion&quot;, previousVersion.getValue()));</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">					if (result.hasNext()) {</span>
<span class="fc" id="L507">						parameters.put(&quot;id&quot;, result.single().get(&quot;id&quot;).asLong());</span>
<span class="fc" id="L508">						mergeOrMatchAndMaybeCreate = &quot;MATCH (p) WHERE id(p) = $id WITH p &quot;;</span>
					} else {
<span class="fc" id="L510">						mergeOrMatchAndMaybeCreate = &quot;CREATE (p:__Neo4jMigration {version: $previousVersion}) &quot;;</span>
					}
				}

<span class="fc" id="L514">				return t.run(</span>
						mergeOrMatchAndMaybeCreate
							+ &quot;CREATE (c:__Neo4jMigration) SET c = $appliedMigration, c.migrationTarget = $migrationTarget &quot;
							+ &quot;MERGE (p) - [:MIGRATED_TO {at: datetime({timezone: 'UTC'}), in: duration( {milliseconds: $executionTime} ), by: $installedBy, connectedAs: $neo4jUser}] -&gt; (c)&quot;,
						parameters)
<span class="fc" id="L519">					.consume();</span>
			});
		}

<span class="fc" id="L523">		return appliedMigration.getVersion();</span>
	}

	private static Map&lt;String, Object&gt; toProperties(Migration migration) {

<span class="fc" id="L528">		Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();</span>

<span class="fc" id="L530">		properties.put(PROPERTY_MIGRATION_VERSION, migration.getVersion().getValue());</span>
<span class="fc" id="L531">		properties.put(PROPERTY_MIGRATION_DESCRIPTION, migration.getDescription());</span>
<span class="fc" id="L532">		properties.put(&quot;type&quot;, getMigrationType(migration).name());</span>
<span class="fc" id="L533">		properties.put(&quot;source&quot;, migration.getSource());</span>
<span class="fc" id="L534">		migration.getChecksum().ifPresent(checksum -&gt; properties.put(&quot;checksum&quot;, checksum));</span>

<span class="fc" id="L536">		return Collections.unmodifiableMap(properties);</span>
	}

	/**
	 * Returns the type of the migration in question. It's not part of the API so that it is not possible to be
	 * overwritten by classes implementing {@link JavaBasedMigration}.
	 *
	 * @param migration The migration whose type should be computed
	 * @return The type of the migration.
	 */
	static MigrationType getMigrationType(Migration migration) {

		MigrationType type;
<span class="fc bfc" id="L549" title="All 2 branches covered.">		if (migration instanceof JavaBasedMigration) {</span>
<span class="fc" id="L550">			type = MigrationType.JAVA;</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">		} else if (migration instanceof AbstractCypherBasedMigration) {</span>
<span class="fc" id="L552">			type = MigrationType.CYPHER;</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">		} else if (migration instanceof CatalogBasedMigration) {</span>
<span class="fc" id="L554">			type = MigrationType.CATALOG;</span>
		} else {
<span class="nc" id="L556">			throw new MigrationsException(&quot;Unknown migration type: &quot; + migration.getClass());</span>
		}
<span class="fc" id="L558">		return type;</span>
	}

	static String toString(Migration migration) {

<span class="fc" id="L563">		return String.format(&quot;%s (\&quot;%s\&quot;)&quot;, migration.getVersion(), migration.getDescription());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>