<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ChainBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Neo4j Migrations (Test Results)</a> &gt; <a href="../index.html" class="el_bundle">neo4j-migrations</a> &gt; <a href="index.source.html" class="el_package">ac.simons.neo4j.migrations.core</a> &gt; <span class="el_source">ChainBuilder.java</span></div><h1>ChainBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ac.simons.neo4j.migrations.core;

import ac.simons.neo4j.migrations.core.MigrationChain.ChainBuilderMode;
import ac.simons.neo4j.migrations.core.MigrationChain.Element;

import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.neo4j.driver.Result;
import org.neo4j.driver.Session;
import org.neo4j.driver.types.IsoDuration;
import org.neo4j.driver.types.Node;
import org.neo4j.driver.types.Path;
import org.neo4j.driver.types.Relationship;

/**
 * Builder for retrieving information about a database and creating a chain containing applied and pending migrations.
 *
 * @author Michael J. Simons
 * @soundtrack Kettcar - Ich vs. wir
 * @since 0.0.4
 */
final class ChainBuilder {

	/**
	 * A flag to force the chain builder into verification mode.
	 */
	private final boolean alwaysVerify;

	ChainBuilder() {
<span class="fc" id="L52">		this(false);</span>
<span class="fc" id="L53">	}</span>

<span class="fc" id="L55">	ChainBuilder(boolean alwaysVerify) {</span>
<span class="fc" id="L56">		this.alwaysVerify = alwaysVerify;</span>
<span class="fc" id="L57">	}</span>

	/**
	 * @param context              The current context
	 * @param discoveredMigrations A list of migrations sorted by {@link Migration#getVersion()}.
	 *                             It is not yet known whether those are pending or not.
	 * @return The full migration chain.
	 * @see #buildChain(MigrationContext, List, boolean, ChainBuilderMode)
	 */
	MigrationChain buildChain(MigrationContext context, List&lt;Migration&gt; discoveredMigrations) {
<span class="fc" id="L67">		return buildChain(context, discoveredMigrations, false, ChainBuilderMode.COMPARE);</span>
	}

	/**
	 * @param context              The current context
	 * @param discoveredMigrations A list of migrations sorted by {@link Migration#getVersion()}.
	 *                             It is not yet known whether those are pending or not.
	 * @param detailedCauses       set to {@literal true} to add causes to possible exceptions
	 * @return The full migration chain.
	 */
	MigrationChain buildChain(MigrationContext context, List&lt;Migration&gt; discoveredMigrations, boolean detailedCauses, ChainBuilderMode infoCmd) {

<span class="fc" id="L79">		final Map&lt;MigrationVersion, Element&gt; elements = buildChain0(context, discoveredMigrations, detailedCauses,</span>
			infoCmd);
<span class="fc" id="L81">		return new DefaultMigrationChain(context.getConnectionDetails(), elements);</span>
	}

	private Map&lt;MigrationVersion, Element&gt; buildChain0(MigrationContext context, List&lt;Migration&gt; discoveredMigrations, boolean detailedCauses, ChainBuilderMode infoCmd) {

		Map&lt;MigrationVersion, Element&gt; appliedMigrations =
<span class="fc bfc" id="L87" title="All 2 branches covered.">			infoCmd == ChainBuilderMode.LOCAL ? Collections.emptyMap() : getChainOfAppliedMigrations(context);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">		if (infoCmd == ChainBuilderMode.REMOTE) {</span>
			// Only looking at remote, assume everything is applied
<span class="fc" id="L90">			return Collections.unmodifiableMap(appliedMigrations);</span>
		}

<span class="fc" id="L93">		Map&lt;MigrationVersion, Element&gt; fullMigrationChain = new LinkedHashMap&lt;&gt;(</span>
<span class="fc" id="L94">			discoveredMigrations.size() + appliedMigrations.size());</span>
<span class="fc" id="L95">		int i = 0;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (Map.Entry&lt;MigrationVersion, Element&gt; entry : appliedMigrations.entrySet()) {</span>
<span class="fc" id="L97">			MigrationVersion expectedVersion = entry.getKey();</span>
<span class="fc" id="L98">			Optional&lt;String&gt; expectedChecksum = entry.getValue().getChecksum();</span>

			Migration newMigration;
			try {
<span class="fc" id="L102">				newMigration = discoveredMigrations.get(i);</span>
<span class="fc" id="L103">			} catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L104">				String message = &quot;More migrations have been applied to the database than locally resolved.&quot;;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">				if (detailedCauses) {</span>
<span class="fc" id="L106">					throw new MigrationsException(message, e);</span>
				}
<span class="fc" id="L108">				throw new MigrationsException(message);</span>
<span class="fc" id="L109">			}</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">			if (!newMigration.getVersion().equals(expectedVersion)) {</span>
<span class="fc" id="L111">				throw new MigrationsException(&quot;Unexpected migration at index &quot; + i + &quot;: &quot; + Migrations.toString(newMigration) + &quot;.&quot;);</span>
			}

<span class="pc bpc" id="L114" title="1 of 6 branches missed.">			if ((context.getConfig().isValidateOnMigrate() || alwaysVerify) &amp;&amp; !matches(expectedChecksum, newMigration)) {</span>
<span class="fc" id="L115">				throw new MigrationsException(&quot;Checksum of &quot; + Migrations.toString(newMigration) + &quot; changed!&quot;);</span>
			}
			// This is not a pending migration anymore
<span class="fc" id="L118">			fullMigrationChain.put(expectedVersion, entry.getValue());</span>
<span class="fc" id="L119">			++i;</span>
<span class="fc" id="L120">		}</span>

		// All remaining migrations are pending
<span class="fc bfc" id="L123" title="All 2 branches covered.">		while (i &lt; discoveredMigrations.size()) {</span>
<span class="fc" id="L124">			Migration pendingMigration = discoveredMigrations.get(i++);</span>
<span class="fc" id="L125">			Element element = DefaultChainElement.pendingElement(pendingMigration);</span>
<span class="fc" id="L126">			fullMigrationChain.put(pendingMigration.getVersion(), element);</span>
<span class="fc" id="L127">		}</span>

<span class="fc" id="L129">		return Collections.unmodifiableMap(fullMigrationChain);</span>
	}

	static boolean matches(Optional&lt;String&gt; expectedChecksum, Migration newMigration) {

<span class="fc bfc" id="L134" title="All 2 branches covered.">		if (expectedChecksum.equals(newMigration.getChecksum())) {</span>
<span class="fc" id="L135">			return true;</span>
		}

<span class="fc bfc" id="L138" title="All 4 branches covered.">		if (!(newMigration instanceof MigrationWithPreconditions) || !expectedChecksum.isPresent()) {</span>
<span class="fc" id="L139">			return false;</span>
		}

<span class="fc" id="L142">		return ((MigrationWithPreconditions) newMigration).getAlternativeChecksums().contains(expectedChecksum.get());</span>
	}

	private Map&lt;MigrationVersion, Element&gt; getChainOfAppliedMigrations(MigrationContext context) {

<span class="fc" id="L147">		String query = &quot;&quot;</span>
			+ &quot;MATCH p=(b:__Neo4jMigration {version:'BASELINE'}) - [r:MIGRATED_TO*] -&gt; (l:__Neo4jMigration) \n&quot;
			+ &quot;WHERE coalesce(b.migrationTarget,'&lt;default&gt;') = coalesce($migrationTarget,'&lt;default&gt;') AND NOT (l)-[:MIGRATED_TO]-&gt;(:__Neo4jMigration)\n&quot;
			+ &quot;RETURN p&quot;;

<span class="fc" id="L152">		try (Session session = context.getSchemaSession()) {</span>
<span class="fc" id="L153">			return session.readTransaction(tx -&gt; {</span>
<span class="fc" id="L154">				Map&lt;MigrationVersion, Element&gt; chain = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L155">				String migrationTarget = context.getConfig().getMigrationTargetIn(context).orElse(null);</span>
<span class="fc" id="L156">				Result result = tx.run(query, Collections.singletonMap(&quot;migrationTarget&quot;, migrationTarget));</span>
				// Might be empty (when nothing has applied yet)
<span class="fc bfc" id="L158" title="All 2 branches covered.">				if (result.hasNext()) {</span>
<span class="fc" id="L159">					result.single().get(&quot;p&quot;).asPath().forEach(segment -&gt; {</span>
<span class="fc" id="L160">						Element chainElement = DefaultChainElement.appliedElement(segment);</span>
<span class="fc" id="L161">						chain.put(MigrationVersion.withValue(chainElement.getVersion()), chainElement);</span>
<span class="fc" id="L162">					});</span>
				}
<span class="fc" id="L164">				return chain;</span>
			});
		}
	}

	private static class DefaultMigrationChain implements MigrationChain {

		private final ConnectionDetails connectionDetailsDelegate;

		private final Map&lt;MigrationVersion, Element&gt; elements;

<span class="fc" id="L175">		DefaultMigrationChain(ConnectionDetails connectionDetailsDelegate, Map&lt;MigrationVersion, Element&gt; elements) {</span>
<span class="fc" id="L176">			this.connectionDetailsDelegate = connectionDetailsDelegate;</span>
<span class="fc" id="L177">			this.elements = elements;</span>
<span class="fc" id="L178">		}</span>

		@Override
		public String getServerAddress() {
<span class="fc" id="L182">			return connectionDetailsDelegate.getServerAddress();</span>
		}

		@Override
		public String getServerVersion() {
<span class="fc" id="L187">			return connectionDetailsDelegate.getServerVersion();</span>
		}

		@Override
		public String getServerEdition() {
<span class="fc" id="L192">			return connectionDetailsDelegate.getServerEdition();</span>
		}

		@Override
		public String getUsername() {
<span class="fc" id="L197">			return connectionDetailsDelegate.getUsername();</span>
		}

		@Override
		public Optional&lt;String&gt; getOptionalDatabaseName() {
<span class="fc" id="L202">			return connectionDetailsDelegate.getOptionalDatabaseName();</span>
		}

		@Override
		public Optional&lt;String&gt; getOptionalSchemaDatabaseName() {
<span class="fc" id="L207">			return connectionDetailsDelegate.getOptionalSchemaDatabaseName();</span>
		}

		@SuppressWarnings(&quot;deprecation&quot;)
		@Override
		public String getDatabaseName() {
<span class="fc" id="L213">			return getOptionalDatabaseName().orElse(null);</span>
		}

		@Override
		public boolean isApplied(String version) {
<span class="fc" id="L218">			Element element = this.elements.get(MigrationVersion.withValue(version));</span>
<span class="pc bpc" id="L219" title="1 of 4 branches missed.">			return element != null &amp;&amp; element.getState() == MigrationState.APPLIED;</span>
		}

		@Override
		public Collection&lt;Element&gt; getElements() {
<span class="fc" id="L224">			return this.elements.values();</span>
		}
	}

	private static class DefaultChainElement implements Element {

		static class InstallationInfo {

			private final ZonedDateTime installedOn;

			private final String installedBy;

			private final Duration executionTime;

<span class="fc" id="L238">			InstallationInfo(ZonedDateTime installedOn, String installedBy, Duration executionTime) {</span>
<span class="fc" id="L239">				this.installedOn = installedOn;</span>
<span class="fc" id="L240">				this.installedBy = installedBy;</span>
<span class="fc" id="L241">				this.executionTime = executionTime;</span>
<span class="fc" id="L242">			}</span>

			ZonedDateTime getInstalledOn() {
<span class="fc" id="L245">				return installedOn;</span>
			}

			String getInstalledBy() {
<span class="fc" id="L249">				return installedBy;</span>
			}

			Duration getExecutionTime() {
<span class="fc" id="L253">				return executionTime;</span>
			}
		}

		static Element appliedElement(Path.Segment appliedMigration) {

<span class="fc" id="L259">			Node targetMigration = appliedMigration.end();</span>
<span class="fc" id="L260">			Map&lt;String, Object&gt; properties = targetMigration.asMap();</span>

<span class="fc" id="L262">			Relationship migrationProperties = appliedMigration.relationship();</span>
<span class="fc" id="L263">			ZonedDateTime installedOn = migrationProperties.get(&quot;at&quot;).asZonedDateTime();</span>
<span class="fc" id="L264">			String installedBy = String.format(&quot;%s/%s&quot;, migrationProperties.get(&quot;by&quot;).asString(),</span>
<span class="fc" id="L265">				migrationProperties.get(&quot;connectedAs&quot;).asString());</span>
<span class="fc" id="L266">			IsoDuration storedExecutionTime = migrationProperties.get(&quot;in&quot;).asIsoDuration();</span>
<span class="fc" id="L267">			Duration executionTime = Duration.ofSeconds(storedExecutionTime.seconds())</span>
<span class="fc" id="L268">				.plusNanos(storedExecutionTime.nanoseconds());</span>

<span class="fc" id="L270">			return new DefaultChainElement(MigrationState.APPLIED,</span>
<span class="fc" id="L271">				MigrationType.valueOf((String) properties.get(&quot;type&quot;)), (String) properties.get(&quot;checksum&quot;),</span>
<span class="fc" id="L272">				(String) properties.get(&quot;version&quot;), (String) properties.get(&quot;description&quot;),</span>
<span class="fc" id="L273">				(String) properties.get(&quot;source&quot;), new InstallationInfo(installedOn, installedBy, executionTime));</span>
		}

		static Element pendingElement(Migration pendingMigration) {
<span class="fc" id="L277">			return new DefaultChainElement(MigrationState.PENDING, Migrations.getMigrationType(pendingMigration),</span>
<span class="fc" id="L278">				pendingMigration.getChecksum().orElse(null), pendingMigration.getVersion().getValue(),</span>
<span class="fc" id="L279">				pendingMigration.getDescription(), pendingMigration.getSource(), null);</span>
		}

		private final MigrationState state;

		private final MigrationType type;

		private final String checksum;

		private final String version;

		private final String description;

		private final String source;

		private final InstallationInfo installationInfo;

		private DefaultChainElement(MigrationState state, MigrationType type, String checksum,
<span class="fc" id="L297">			String version, String description, String source, InstallationInfo installationInfo) {</span>
<span class="fc" id="L298">			this.state = state;</span>
<span class="fc" id="L299">			this.type = type;</span>
<span class="fc" id="L300">			this.checksum = checksum;</span>
<span class="fc" id="L301">			this.version = version;</span>
<span class="fc" id="L302">			this.description = description;</span>
<span class="fc" id="L303">			this.source = source;</span>
<span class="fc" id="L304">			this.installationInfo = installationInfo;</span>
<span class="fc" id="L305">		}</span>

		@Override
		public MigrationState getState() {
<span class="fc" id="L309">			return state;</span>
		}

		@Override
		public MigrationType getType() {
<span class="fc" id="L314">			return type;</span>
		}

		@Override
		public Optional&lt;String&gt; getChecksum() {
<span class="fc" id="L319">			return Optional.ofNullable(checksum);</span>
		}

		@Override
		public String getVersion() {
<span class="fc" id="L324">			return version;</span>
		}

		@Override
		public String getDescription() {
<span class="fc" id="L329">			return description;</span>
		}

		@Override
		public String getSource() {
<span class="fc" id="L334">			return source;</span>
		}

		@Override
		public Optional&lt;ZonedDateTime&gt; getInstalledOn() {
<span class="fc" id="L339">			return Optional.ofNullable(installationInfo).map(InstallationInfo::getInstalledOn);</span>
		}

		@Override
		public Optional&lt;String&gt; getInstalledBy() {
<span class="fc" id="L344">			return Optional.ofNullable(installationInfo).map(InstallationInfo::getInstalledBy);</span>
		}

		@Override
		public Optional&lt;Duration&gt; getExecutionTime() {
<span class="fc" id="L349">			return Optional.ofNullable(installationInfo).map(InstallationInfo::getExecutionTime);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>